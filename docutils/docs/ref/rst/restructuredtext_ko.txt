.. -*- coding: utf-8 -*-

=======================================
 reStructuredText 마크업(Markup) 설명서
=======================================

:저자: David Goodger
:메일주소: docutils-develop@lists.sourceforge.net
:개정: $Revision$
:날짜: $Date$
:저작권: 이 문서는 공공 도메인에 속해있다.

.. Note::

   이 문서는 전문적인 세부 설명서이다; 이것은 튜토리얼이나 입문서가 아니다.
   만약 reStructuredText 처음 접한다면, `A ReStructuredText Primer`_ 과
   `Quick reStructuredText`_ 사용자 참조 문서를 먼저 읽기 바란다.

.. _A ReStructuredText Primer: ../../user/rst/quickstart_ko.html
.. _Quick reStructuredText: ../../user/rst/quickref_ko.html


reStructuredText_ 는 단순하고 직관적인 구조를 이용해서 문서의 체계를 표현하는
평문(plaintext)이다. 이 구조는 처리되기 전이나 처리된 후에 똑같이 읽기 쉽다.
이 문서는 그 자체로 reStructuredText의 예시다. (예를 들어, 텍스트 문서를 읽고
있다면 처리되기 전이며, HTML을 읽고 있다면 처리된 후다.)
reStructuredText parser는 Docutils_ 의 구성요소이다.

단순하고, 내재적인(implicit) 마크업은 섹션 제목이나 bullet 리스트, 강조 같은
특수한 구조를 표현하기 위해 사용된다. 사용되는 마크업은 가능한 간결하게 되어있다.
덜 사용되는 구조나 기본 reStructuredText 문법의 확장 기능은 더 정교하고
명시적(explicit)이다.

reStructuredText 는 inline 프로그램 문서 일부(e.g 파이썬 독스트링(docstring))
같이 매우 짧거나 이 문서와 같이 매우 긴 길이의 문서에도 적용할 수 있다.

첫 번째 섹션은 reStructuredText 마크업 구문의 예시와 함께 간단한 개관으로
이루어져있다. 완전한 설명서는 `Syntax Details`_ 섹션에서 제공된다.

마크업이 처리되지 않은 `Literal blocks`_ 은 평문의 마크업을 나타내는
예시를 보여주기 위해 사용되었다.


.. contents::


-----------------------
 Quick Syntax Overview
-----------------------

reStructuredText 문서는 본문이나 block-level 구성되어 있으며 섹션으로 나누어져
있다. Sections_ 은 제목 스타일(밑줄(underlines)과 선택적인(optional) 윗줄(overlines))로
표현되어 있다. 섹션은 본문 요소(elements)를 포함하고 있으며 하위 섹션이 있을 수
있다. 몇몇의 본문 요소는 리스트 항목(단락과 기타 본문 요소를)을 포함하는 리스트
같은 추가적인 요소를 포함하고 있다. 단락과 같은 다른 것들은 텍스트와
`inline markup`_ 요소를 포함하고 있다.

`body elements`_ 예시:

- Paragraphs_ (과 `inline markup`_)::

      단락은 텍스트와 인라인 마크업을 포함하고 있다:
      *강조*, **강한 강조**, `해석된 텍스트`, ``인라인 리터럴``,
      독립형 하이퍼링크(standalone hyperlinks) (http://www.python.org),
      외부 하이퍼링크(external hyperlinks) (Python_),
      내부적 상호 참조(internal cross-references) (example_),
      각주 참조(footnote references) ([1]_), 인용 참조(citation references)
      ([CIT2002]_), 대체 참조(substitution references) (|example|),
      _`인라인 내부 타겟(inline internal targets)`.

      단락은 빈 줄로 나눠져있고 왼쪽 정렬되어있다.

- 리스트 타입 다섯가지:

  1. `Bullet lists`_::

         - 이것은 bullet list다.

         - 글머리 기호(Bullets)는 "*", "+", "-"를 사용할 수 있다.

  2. `Enumerated lists`_::

         1. 이것은 enumerated list다.

         2. 숫자는 아라비아 숫자, 글자 로마 숫자를 사용할 수 있다.

  3. `Definition lists`_::

         개념
             Definition lists 용어와 용어를 정의하는 부분을 결합시킨다.

         사용 방식
             용어는 한 줄의 구문이고, 정의하는 부분은 하나 이상의 단락이나
             본문 요소로 구성되어 있으며 용어보다 들여쓰기 되어 있어야 한다.

  4. `Field lists`_::

         :개념: Field lists는 필드 이름(field names)와 데이터 베이스 기록
                같은 필드 내용을 결합시킨다. 확장구문의 일부로 사용될 수 있다.

         :방법: The field는 콜론, 필드 이름, 콜론으로 표시한다.

                필드의 본문은 하나 이상의 본문 요소를 포함하고 있으며
                필드 이름을 표시한 것보다 들여쓰기 되어 있어야 한다.

  5. `Option lists`_, 커맨드라인 옵션(command-line options)을 위한 리스트::

         -a            커맨드라인 옵션 "a"
         -b file       인수(arguments)를 가지는 옵션과
                       그에 대한 긴 설명
         --long        긴(long) 옵션
         --input=file  긴 옵션 또한 인수를 가질 수
                       있다
         /V            DOS/VMS 스타일 옵션도 가능하다

     옵션과 설명 사이에 최소한 두 칸 이상 띄어쓰기가 되어 있어야 한다.

- `Literal blocks`_::

      Literal blocks은 들여쓰기 되거나 라인 접두사로 인용된(line-prefix-quoted)
      블럭이며 선행된 단락의 끝에 더블 콜론(double-colon)("::")을 써서 나타낼
      수 있다. (이곳 처럼 -->)::

          if 리터럴_블럭에서는 :
              텍스트 = '그대로 표현된다'
              띄어쓰기와_개행 = '보존된다'
              마크업_처리 = 이루어지지 않는다

- `Block quotes`_::

      블럭 인용(Block quotes)은 본문 요소를 들여쓰면 된다:

          This theory, that is mine, is mine.

          -- Anne Elk (Miss)

- `Doctest blocks`_::

      >>> print '파이썬 사용 예제; ">>>"로 시작된다'
      파이썬 사용 예제; ">>>"로 시작된다
      >>> print '(대화형(interactive) Python 세션에서 복사, 붙여넣을 수 있다)'
      (대화형(interactive) Python 세션에서 복사, 붙여넣을 수 있다)

- Two syntaxes for tables_:

  1. `Grid tables`_; 완전하지만 복잡하고 장황하다(verbose)::

         +-------------------+----------+--------+
         | 헤더 행, 1 열      | 헤더 2   | 헤더 3 |
         +===================+==========+========+
         | 본문 1 행, 1 열    | 2 열     | 3 열   |
         +-------------------+----------+--------+
         | 본문 2 행          | 셀 병합 가능       |
         +-------------------+-------------------+

  2. `Simple tables`_;  쉽고 간결하지만 제한적이다::

         ====================  ==========  ==========
         헤더 행, 1 열          헤더 2      헤더 3
         ====================  ==========  ==========
         본문 1 행, 1 열        2 열        3 열
         본문 2 행              셀의 열 병합 가능
         ====================  ======================

- `Explicit markup blocks`_ 명시적(explicit) 블럭 마커, 마침표 두 개,
  띄어쓰기로 시작한다:

  - Footnotes_::

        .. [1] 각주는 적어도 띄어쓰기 3번 이상으로 일관되게 들여쓰여진
           본문 요소를 포함한다.

  - Citations_::

        .. [CIT2002] 라벨이 문자인 것을 제외하면 각주와 같다.

  - `Hyperlink targets`_::

        .. _Python: http://www.python.org

        .. _example:

        위의 "_example" 타겟이 이 단락을 가리킨다.

  - Directives_::

        .. image:: mylogo.png

  - `Substitution definitions`_::

        .. |기호| image:: symbol.png

  - Comments_::

        .. 코멘트는 두 점과 띄어쓰기 한 번으로 시작된다. 각주/인용 구문,
           하이퍼링크 타겟, 명령(directives), 대체 정의(substitution definitions)
           를 제외하고는 어떤 것을 써도 상관 없다.


----------------
 Syntax Details
----------------

아래의 설명은 구문 구조에 대응하는 "doctree elements" (문서 트리 요소의 이름
(document tree element names); XML DTD 일반 식별자(generic indentifier))
를 나열하고 있다.  요소의 체계에 관한 세부사항은, `The
Docutils Document Tree`_ 와 `Docutils Generic DTD`_ XML 문서 타입 정의를
참고하라.


Whitespace
==========

들여쓰기(indentation_)는 띄어쓰기를 사용할 것을 추천하지만 탭도 사용할 수 있다.
탭은 띄어쓰기로 변환될 것이다.  탭 정지는 8번째 열마다 있다.

다른 whitespace 문자 (폼 피드(form feeds) [chr(12)]와 수직 탭(vertical tabs)
[chr(11)])은 처리 전에 단일 띄어쓰기로 변환된다.


Blank Lines
-----------

공백 행은 단락이나 다른 요소를 구분하기 위해 사용된다.
여러 개의 공백 행은 모든 공백이 보존되는 리터럴 블럭 안을 제외하고는
하나의 공백 행과 같다. 공백 행은 마크업이 요소 구분을 명확하게 할 때 들여쓰기와
함께 생략될 수 있다. 문서의 첫 번째 줄은 공백행이 앞에 있는 것으로 처리되며
문서의 마지막 줄은 공백 핵이 다음에 오는 것으로 처리된다.


Indentation
-----------

들여쓰기는 블럭 인용이나 definition list 항목 내의 정의, 지역적으로 내포되어있는
내용(local nested content)을 나타낼 때에만 중요하게 사용된다:

- list 항목 내용 (여러 줄의 내용이 있는 list 항목과 내포된 리스트를 포함하여
  리스트 아이템에 있는 여러 본문 요소),
- 리터럴 블럭 내용,
- 명시적 마크업 블럭의 내용.

현재 레벨에 비해 적게 들여쓰여진 텍스트는 (들여쓰기가 되지 않은 텍스트나 내어쓰기)
현재 레벨의 들여쓰기를 끝내버린다.

모든 줄의 들여쓰기가 중요하기 때문에, 들여쓰기 레벨은 일관성이 있어야 한다.
예를 들어, `block quotes`_ 의 유일한 마크업 표시기이다::

    이 단락은 레벨이 가장 높은 단락이다.

        이 단락은 첫 번째 레벨의 블럭 인용이다.

        첫 번째 레벨 블럭 인용의 단락 2이다.

블럭 인용 내에서 여러 레벨의 들여쓰기를 사용하면 구조를 복합적으로 만들 수 있다::

    이 단락은 레벨이 가장 높은 단락이다.

        이 단락은 첫 번째 레벨 블럭 인용에 속해 있다.

            이 단락은 두 번째 레벨 블럭 인용에 속해 있다.

    또 다른 가장 높은 레벨의 단락.

            이 단락은 두 번째 레벨 블럭 인용에 속해 있다.

        이 단락은 첫 번째 레벨 블럭 인용에 속해 있다. 위에 있는 두 번쨰 레벨
        블럭 인용은 이 첫 번째 레벨 인용 블럭의 안에 있다.

단락이나 다른 구문이 한 줄 이상의 텍스트로 구성되어 있을 때, 각 행은 반드시
왼쪽 정렬 되어 있어야 한다::

    이 것은 한 단락이다. 이 단락의 각 행은
    왼쪽으로 정렬되어 있다.

        이 단락은 문제가 있다. 각 행이
    왼쪽으로 정렬되어 있지 않다.  이 경우
      해석이 잘못됨과 동시에 parser에 의해
        경고나 에러 메세지가
      발생할 것이다


몇몇의 구문는 마커로 시작하고, 구조의 구문은 마커에 비해 반드시 들여쓰기
되어 있어야 한다. 간단한 마커를 사용하는 구조의 경우
(`bullet lists`_, `enumerated lists`_, footnotes_, citations_,
`hyperlink targets`_, directives_, and comments_), 본문의 들여쓰기 레벨은
마커와 같은 줄에서 시작하는 텍스트의 첫 번째 줄 위치에 의해 결정된다.
예를 들어, bullet list 본문은 글머리 기호(bullet)의 왼쪽 가장자리보다 최소한
두 열 이상은 들여쓰여져야 한다::

    - 이것은 bullet list 항목 단락의 첫 번째 줄이다.
      모든 줄은 반드시 첫 줄에 따라서 정렬되어야 한다.  [1]_

          이 들여쓰여진 단락은 인용 블럭으로 해석된다.

    이 단락은 충분히 들여쓰여지지 않았기 때문에
    리스트 항목에 속하지 않는다.

    .. [1] 이건 각주이며 두 번째 줄은 각주 레이블의 시작 부분에
       정렬되어 있다. 들여쓰기는 ".." 마커가 결정한다.

임의의 텍스트를 포합하는 복잡한 마커를 사용하는 구조 (`field lists`_ 와 `option
lists`_) 는 마커의 *다음* 에 오는 첫 번째 줄이 본문의 왼쪽 가장자리를 결정한다.
예를 들어, field lists는 필드 이름을 포함한 굉장히 긴 마커를 쓸 수도 있다::

    :Hello: 이 필드는 짧은 필드 이름을 가지고 있다, 그렇기 때문에 첫 번째
            본문을 정렬시키는 것은 가능하다.

    :Number-of-African-swallows-required-to-carry-a-coconut:
        이 필드 본문은 첫 번쨰 줄의 가장자리를 따라 정렬시키는 것은 매우 힘들다.
        이 경우 마커와 같은 라인에서 본문을 시작하지 않는 것이 더 낫다.


Escaping Mechanism
==================

7-bit ASCII 일반 텍스트 문서에 보편적으로 사용 가능한 문자 집합은 제한되어
있다. 마크업에 어떤 문자를 쓰더라도, 그 문자들은 텍스트에서 원래 여러 의미를 가지고
있을 것이다. 그러므로 마크업 문자는 가끔씩 **마크업으로 의도되지 않은 것처럼**
텍스트에서 나타나야 한다. 마크업 시스템은 마크업을 위해 사용되는 문자의 기본 의미를
무시하기 위한 이스케이핑 메커니즘(Escaping Mechanism)을 요구한다.
eStructuredText는 다른 도메인에서도 일반적으로 사용하는 백슬래쉬를 사용한다.

non-URI contexts의 공백 문자를 제외하고 백슬레쉬가 앞에 쓰여진 문자는 이스케이프된다.
이스케이프된 문자는 문자 그 자체를 나타내고 마크업 역할을 하지 않는다.
백슬래쉬는 출력물에서 제외된다. 문자 그 자체로의 백슬래쉬는 백슬래쉬를 두 번
연달아 써서 나타낼 수 있다. (첫 번째 백슬래쉬가 두 번째 백슬래쉬를
이스케이프 하게 만들어서 두 번째 백슬래쉬가 이스케이핑 역할을 못 하도록 막는다.)

non-URI contexts에서는,
백슬래쉬로 이스케이프된 공백 문자는 문서에서 제거된다.
이것은 문자 레벨을 허용하게 한다 `inline markup`_.

URIs에서는, 백슬래쉬로 이스케이프된 공백은 단일 띄어쓰기로 나타난다.

백슬래쉬가 특별한 의미를 갖지 않는 두가지 경우가 있다:
바로 리터럴 블럭과 인라인 리터럴이다. 이 경우에는 백슬래쉬를 연달아 두 번 쓰지
않아도 백슬래쉬 그대로 표현된다.

reStructuredText 설명서와 parser는 입력 텍스트의 추출과 표현에 대한
이슈들을 해결하지 않는다는 점을 참고하기 바란다. (어떤 형식의 텍스트가 어떻게
parser에 도달하는지)
백슬래쉬나 다른 문자들은 특정 context 안에서 문자를 이스케이프시킬 수 있으므로
적절하게 처리되어야 한다. 예를 들어 파이썬은 문자열(string)에서 특정 문자를
이스케이프 시키기 위해 백슬래쉬를 사용하지만 다른 언어는 그렇지 않다.
파이썬 독스트링(doctsring)에서 백슬래쉬가 나타날 때 가장 쉬운 해결첵은
raw docstring을 사용하는 것이다::

    r"""이것이 raw doctring이다. 백슬래쉬 (\)는 처리되지 않는다)."""


Reference Names
===============

간단한 참조 이름은 영글자 숫자와 (인접하지 않고) 분리된 내부 하이픈, 언더스코어,
마침표, 콜론, 기호로 구성된 하나의 단어다; 공백이나 다른 문자는 사용할 수 없다.
각주 라벨 (Footnotes_ & `Footnote References`_), 인용 라벨
(Citations_ & `Citation References`_), `interpreted text`_ 역할,
과 `hyperlink references`_ 단순 참조 이름 구문을 사용한다.

구두점을 사용하거나 이름이 구문(두 개 이상의 띄어쓰기로 연결된 단어)인 참조 이름은
"(phrase-references)"라고 한다.
Phrase-references 백 쿼트(backqouote)에 둘러 싸여진 구문으로 표현되고
백 쿼트 안의 구문이 참조 이름이 된다::

    `my favorite programming language`_ 에 대해서 배우고 싶나?

    .. _my favorite programming language: http://www.python.org

단순 참조도 마음대로 백쿼트를 사용할 수 있다.

참조 이름은 대소문자를 구분하지 않고 공백 중립적(whitespace-neutral)이다.
내부적으로 참조 이름을 변환할 때:

- 공백은 표준화 된다. (하나 이상의 공백, 수평 수직 탭,
  새 줄 문자, carriage returns, form feeds는 하나의 띄어쓰기로
  해석된다.), 그리고

- 문자도 표준화 된다. (모든 영어 문자는 소문자로 변환된다.)

예를 들어, 아래의 `hyperlink references`_ 는 모두 같다::

    - `A HYPERLINK`_
    - `a    hyperlink`_
    - `A
      Hyperlink`_

Hyperlinks_, footnotes_, and citations_ 는 참조 이름에 대해서 같은 namespace를
공유한다. 인용 라벨 (단순 참조 이름)과 수동으로 번호가 매겨진 각주 (숫자)는
다른 하이퍼링크 이름과 마찬가지로 같은 데이터베이스에 속하게 된다.
이 말은 각주 참조(``[1]_``)과 연결되는 각주("``.. [1]``")는
하이퍼 링크 참조(1_)과도 연결될 수 있다는 의미이다.
물론, 각 종류의 참조(hyperlink, footnote, citation)는 다른 방식으로
해석되고 처리될 것이다. 따라서 참조 이름의 충돌을 피하기 위해서는 주의가 필요하다.


Document Structure
==================

Document
--------

Doctree element: document.

파싱된 reStructuredText 문서의 최상위 레벨 요소는 "document" 요소다.
최초의 파싱이 끝나면, document 요소는 `body elements`_, transitions_,
sections_ 으로 구성된 문서 fragment을 포함하는 단순한 컨테이너이며, 문서 제목이나
다른 bibliographic 요소는 없다. parser를 호출하는 코드는 하나 이상의 추가적인
post-parse transforms_ 을 실행시키며, 문서 fragment를 제목과 기타 메타데이터 요소
(저자, 날짜, 기타; `Bibliographic Fields`_ 참고)를 가진 완전한 문서로 재배열 합니다.

.. _document title:

엄밀히 말하면, reStructuredText에서 문서 제목과 부제목을 명시적으로 표현할 수
있는 방법은 없다. [#]_ 대신의, 하나의 최상위 레벨 섹션 타이틀(아래의 Sections_ 참고)
을 문서의 제목으로 처리할 수 있다.
마찬가지로 하나의 차 상위 레벨의 섹션 제목을 문서 제목의 바로 아래에 놓으면
문서의 부제목으로 처리할 수 있다. 그러면 나머지 섹션은 1 또는 2 레벨씩 오르게 된다.
자세한 내용은 `DocTitle transform`_ 을 확인하라.

.. [#] `title`_ 설정을 변경하면 문서의 제목을 문서 본문의 일부가 되지 않도록
   조정할 수 있다.

.. _title: ../../user/config.html#title


Sections
--------

Doctree elements: section, title.

섹션은 마크업을 통해 꾸며진 각 섹션의 제목을 통해 식별된다:
타이틀 텍스트 아래에 "밑줄" 표시를 하거나 밑줄 표시에 맞춰서 "윗줄"" 표시.
윗줄/밑줄은 단일 구분 문자를 줄의 처음부터 적어도 제목 텍스트의
오른쪽 끝까지 반복해서 형성된 줄을 말한다. 구체적으로 말하면, 밑줄/윗줄에 사용하는
문자는 글자와 숫자가 아니면서 출력 가능한 7-bit ASCII 문자이면 된다 [#]_.
윗줄이 사용되었을 때에는 사용된 문자와 줄의 길이가 밑줄과 같아야 된다.
밑줄만 사용된 꾸미기 스타일은 같은 문자를 사용한 밑줄 윗줄 스타일과 구분된다.
비록 몇몇 출력 형식에 제한이 있지만(HTML은 6레벨 까지) 섹션 제목의 레벨은
제한이 없다.

.. [#] 아래는 섹션 타이틀 꾸미기에 사용될 수 있는 문자들이다::

       ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~

   몇가지 문자들은 다른 문자에 비해 더 적합하다. 아래의 문자들을
   추천한다::

       = - ` : . ' " ~ ^ _ * + #

순서는 고정된 섹션 제목 꾸미기 스타일과 숫자로 강제되는 것이 아니고,
쓰여진 순서대로 자동적으로 정해진다. 첫 번째로 쓰여진 스타일이 가장 바깥쪽
(outermost) 타이틀이 되고, 두 번째 스타일이 부제목, 세 번째가 부부제목이 되는
식이다.

아레는 제목 스타일의 예시다::

    ===============
     Section Title
    ===============

    ---------------
     Section Title
    ---------------

    Section Title
    =============

    Section Title
    -------------

    Section Title
    `````````````

    Section Title
    '''''''''''''

    Section Title
    .............

    Section Title
    ~~~~~~~~~~~~~

    Section Title
    *************

    Section Title
    +++++++++++++

    Section Title
    ^^^^^^^^^^^^^

제목에 밑줄과 윗줄이 모두 있을 때, 제목 텍스트는 위쪽의 처음 두
예시와 같이 들여쓰여질 수 있다. 이것은 단지 미적인 이유 때문일 뿐이라
중요하지는 않다. 밑줄만 쓰는 경우는 텍스트를 들여쓰면 *안* 된다.

제목 아래에 공백 행을 쓰는 것은 선택적인 부분이다. 같거나 더 높은
레벨의 다른 제목 이전의 모든 텍스트는 동일한 한 섹션(또는 하위 섹션 등)
에 포함된다.

모든 섹션 제목 스타일이 다 쓰일 필요는 없으며, 특정한 제목 스타일만 쓸 필요도
없다. 그런, 문서는 섹션 제목 사용에 있어서 일관성을 유지해야 한다: 제목 스타일의
쳬계가 일단 정립이 되면, 모든 섹션은 반드시 그 체계를 따라야 한다.

섹션의 제목은 자동적으로 각 섹션을 가리키는 하이퍼 링크 타겟을 생성한다.
하이퍼 링크 타켓의 텍스트("참조 이름")는 섹션 제목이다. 자세한 설명은`Implicit
Hyperlink Targets`_ 를 참고하라.

섹션은 `body elements`_, transitions_, 내포된(nested) 섹션을 포함할 수 있다.


Transitions
-----------

Doctree element: transition.

    부제를 다는 것 대신에, 문단 사이에 빈 공간을 두거나 기호를 입력하는 것으로
    텍스트가 분리된거나 주제 또는 주안점이 변화된다는 변화를 표현할 수 있다.

    (The Chicago Manual of Style, 14th edition, section 1.80)

Transitions은 장편 단편 소설에서 볼 수 있는데, 한 줄 이상으로 간격을 벌려
비워두거나 별표 줄을 사용한다. Transitions 다른 본문 요소를 분리시킨다.
Transition은 섹션이나 문서를 시작하거나 끝낼 수 없으며, 두개의 transition이
바로 붙어 있을 수도 없다.

Transition 마커를 위한 구문은 구분 문자를 4번 이상 수평적으로 반복시킨 것이다.
이 구문은 제목 텍스트가 없는 섹션 타이틀 밑줄과 똑같다.
Transition 마커는 라인의 전후에 빈 줄이 필요하다::

    Para.

    ----------

    Para.

섹션 제목 밑줄과 다르게, transition 마커의 계층 구조는 강제되지 않으며
transition 마커의 차이는 아무 것도 발생시키지 않는다. 따라서 하나의
일관된 스타일을 사용할 것을 추천한다.

프로세싱 시스템은 원하는 방식으로 자유롭게 transitions을 렌더링할 수 있습니다.
예를 들어, HTML 출력에서는 수평줄 (``<hr>``)이 선택될 것이다.


Body Elements
=============

Paragraphs
----------

Doctree element: paragraph.

단락은 다른 본문 요소를 가리키는 마크업이 없는 왼쪽 정렬된 텍스트 블럭으로
구성되있다. 공백 행은 단락을 다른 본문 요소나 단락과 구분지어 준다. 문단은
`inline markup`_ 을 포함할 수 있다.

구문 다이어그램::

    +------------------------------+
    | 단락                         |
    |                              |
    +------------------------------+

    +------------------------------+
    | 단락                         |
    |                              |
    +------------------------------+


Bullet Lists
------------

Doctree elements: bullet_list, list_item.

"*", "+", "-", "•", "‣", "⁃"로 시작하고 공백 문자로 띄어진 텍스트 블럭은
bullet list 항목(순서가 없는 리스트 항목)이라고 한다. 리스트 항목의
본문은 반드시 글머리 기호(bullet)보다 들여쓰여진 상태로 왼쪽 정렬 되어
있어야 한다; 글머리 기호 바로 다음에 오는 텍스트가 들여쓰기를 결정한다.
예를 들면::

    - 이것은 첫 번째 bullet list 항목이다. 첫 번째 리스트 항목의 위에는
      공백 행이 있어야 한다; 이 단락의 아래처럼 리스트 항목 사이에 공백 행을
      쓰는 것은 선택적인 부분이다.

    - 이것은 리스트의 두 번째 항목의 첫 번째 단락이다.

      이 두 번째 단락은 두 번째 항목의 속해있다. 이 단락의 위에는 공백 행이
      삽입 되어야 한다. 이 단락의 왼쪽 가장자리는 위쪽에 있는 단락에 맞춰야 하며
      모두 글머리 기호보다 들여쓰여져야 한다.

      - 이것은 하위 리스트다. 글머리 기호의 왼쪽 가장자리는 위쪽 텍스트 블럭의
        가장자리를 따라야 한다. 하위 리스트는 또다른 새로운 리스트이기 때문에
        항목의 위 아래에 공백 행이 삽입되어야 한다.

    - 이것은 메인 리스트의 세 번째 항목이다.

    이 단락은 리스트에 속해있지 않다.

아래는 **잘못** 작성된 bullet lists의 예시이다::

    - 첫 번째 줄은 이상이 없다.
    리스트 항목과 단락 사이에는 공백 행이 삽입되어야 한다.
    (경고)

    - 아래의 몇 줄들은 새로운 하위 리스트로 보이지만 실제로는 그렇지 않다:
      - 사이에 공백 행이 삽입되지 않았기 때문에 이것은 하위리스트가
        아니라 연결된 단락이다. 그리고 들여쓰기도 제대로 되어있지 않은 상태다.
      - 이러한 경우 변환 시에 경고가 발생될 수 있다.

구문 다이어그램::

    +------+-----------------------+
    | "- " | 리스트 항목            |
    +------| (본문 요소)+           |
           +-----------------------+


Enumerated Lists
----------------

Doctree elements: enumerated_list, list_item.

Enumerated lists(순서가 있는 리스트)는 bullet lists와 비슷하지만
글머리 기호 대신에 숫자나 문자를 사용한다. enumerator는
enumeration sequence 멤버와 formatting, 뒤따르는 공백으로 구성되어 있다.
아래의 enumeration sequences를 사용할 수 있다:

- 아라비아 숫자: 1, 2, 3, ... (수에 제한이 없다).
- 알파벳 대문자: A, B, C, ..., Z.
- 알파벳 소문자: a, b, c, ..., z.
- 로마 숫자 대문자: I, II, III, IV, ..., MMMMCMXCIX (4999).
- 로마 숫자 소문자: i, ii, iii, iv, ..., mmmmcmxcix (4999).

그리고 자동 enumerator인 "#"를 사용하면 자동적으로 리스트에 숫자를 매길
수 있다. 자동 enumerated lists는 사용할 sequence를 명시적으로 정하면서
사용할 수 있다. 완전 자동 enumerated lists는 1로 시작하고 아라비아 숫자
sequence를 사용한다. (자동 enumerated lists
Docutils 0.3.8.에서 새로 등장했다)

아래의 formatting 스타일들이 사용될 수 있다:

- 구두점이 뒤에 붙은 타입: "1.", "A.", "a.", "I.", "i.".
- 괄호에 의해 둘러쌓인 타입: "(1)", "(A)", "(a)", "(I)", "(i)".
- 괄호가 오른쪽에만 붙은 타입: "1)", "A)", "a)", "I)", "i)".

enumerated list를 파상 할 때, 아래의 경우에는 새로운 리스트가 시작된다:

- enumerator가 현재의 리스트와 다른 시퀀스 타입과 format을 사용했을 경우
  (e.g. "1.", "(a)"를 쓰면 두 개의 리스트를 생성한다).

- enumerators의 순서가 맞지 않는 경우( "1.", "3." 두 개의 리스트
  생성한다).

첫 번째 리스트 항목의 enumerator는 sequence의 첫 번째 문자
("1", "A", "a", "I", or "i")를 사용하는 것을 추천한다. 다른 문자로 시작
해도 되지만 출력 포맷이 지원해주지 못할 수도 있다. 첫 번째 문자가 아닌
다른 문자로 리스트를 시작하면 level-1 [info] 시스템 메세지가 발생할 것이다.

로마 숫자를 사용하는 리스트는 반드시 "I"/"i"나 "II", "XV"같은 여러 개로
이루어진 문자로 시작해야 한다. 다른 한 글자 짜리 로마 문자
("V", "X", "L", "C", "D", "M")로 시작하면 로마 숫자가 아니라 알파벳
글자로 해석될 것이다. 마찬가지로 알파벳을 사용하는 리스트는 로마 숫자로
인식할 수 있기 때문에 "I"/"i"로 리스트를 시작하면 안 된다.

각 enumerated list 항목의 두 번째 줄은 리스트의 유효성을 확인하는데 사용된다.
이는 텍스트가 enumoerator와 동일한 문자로 시작했을 때 일반적인 단락을 잘못해서
리스트 항목으로 인식되는 것을 막기 위함이다. 예를 들면 아래의 텍스트는
일반적인 단락으로 파싱된다::

    A. Einstein was a really
    smart dude.

그러나, 단락이 한 문장일 경우 판단이 애매해진다.
아래의 텍스트는 enumerated list 항목으로 파싱된다::

    A. Einstein was a really smart dude.

enumerator와 동일한 문자("A.", "1.", "(b)", "I)", etc.)로 텍스트가
시작된다면 일반적인 단락으로 파싱되기 위해 이스케이브 되어야 한다::

    \A. Einstein was a really smart dude.

enumerated lists 내에 enumerated lists가 있는 예시::

    1. 항목 1 시작하는 텍스트.

       a) 항목 1a.
       b) 항목 1b.

    2. a) 항목 2a.
       b) 항목 2b.

구문 다이어그램 예시::

    +-------+----------------------+
    | "1. " | 리스트 항목           |
    +-------| (본문 요소)+     |
            +----------------------+


Definition Lists
----------------

Doctree elements: definition_list, definition_list_item, term,
classifier, definition.

각각의 definition list 항목은 용어와 선택적인 classifier, 정의로
이루어져 있다. 용어는 한 줄의 구문이나 단어이다. 선택적인 classifier는 용어와
같은 줄에서 " : " (공백, 콜론, 공백) 다음에 위치한다. 정의는 용어보다 들여쓰기
된 블럭이며 여러 단락과 다른 본문 요소들을 포함할 수 있다.
정의 블럭과 용어 줄 사이에는 공백이 있어서는 안된다(이 부분으로 definition lists와
`block quotes`_ 를 구분한다). definition list의 첫 번째 항목의 위쪽과
마지막 항목의 아래쪽에는 공백 행이 삽입 되어야 하며 그 사이에는 선택적으로
삽입할 수 있다. 예를 들면::

    용어 1
        정의 1.

    용어 2
        정의 2, 단락 1.

        정의 2, 단락 2.

    용어 3 : classifier
        정의 3.

    용어 4 : classifier 1 : classifier 2
        정의 4.

인라인 마크업은 classifier 구분 기호 (" : ")가 인식되기 전에 파싱된다.
구분기호는 인라인 마크업의 외부에서 나타날 때에만 인식된다.

definition list 다양한 방식으로 사용될 수 있다:

- 사전으로 사용할 수 있다. 용어를 단어로 쓰고, classifier로 용어의
  품사(noun, verb, etc.)를 나타내고 아래에서 뜻을 정의하면 된다.

- 프로그램 변수를 설명할 때 사용할 수 있다.  용어는 변수 이름으로 놓고,
  classifier로 변수의 타입(string, integer, etc.)을 표시하고 프로그램에서
  변수가 어떻게 사용되는지 정의하면 된다. 이 definition lists 을 사용하면
  Python 객체 스키마를 기술하고 실행하는 시스템인 Grouch_ 의 classifier 구문이
  지원된다.

구문 다이어그램::

    +----------------------------+
    | 용어 [ " : " classifier ]* |
    +--+-------------------------+--+
       | 정의                       |
       | (본문 요소)+               |
       +----------------------------+


Field Lists
-----------

Doctree elements: field_list, field, field_name, field_body.

Field lists는 directives_ 를 위한 옵션 같은 구문 확장의 일부나 추가적인
처리를 위한 데이터 베이스 형태의 기록을 위해 사용됩니다. 또한 데이터 베이스
기록(라벨 & 데이터 쌍)과 유사한 2열 테이블형태의 구조에도 사용될 수 있다.
reStructuredText 응용 프로그램은 필드 이름을 인식하고 특정 내용의
필드나 필드 본문을 변환할 수 있다. 예시를 확인하려면, 아래의
`Bibliographic Fields`_ 또는, `reStructuredText Directives`_
내에 있는 "image_", "meta_" 명령어(directives)를 참고하라.

.. _field names:

Field lists는 RFC822_ headers을 모델로 *필드 이름* 과 *필드 내용* 을
맵핑(mapping)해준다. 필드 이름은 문자로 구성되어 있지만 이름 안에 콜론(":")을
사용해야 될 경우 백슬래쉬를 사용해 이스케이프 시켜야한다.
인라인 마크업은 필드 이름 안에서 파싱된다. 필드 이름은 추가적으로 처리되거나
변환될 때 대소문자를 구분하지 않는다. 앞, 뒤에 붙은 콜론과 필드 이름은
합쳐서 하나의 필드 마커를 형성한다. 필드 마커 뒤에는 공백문자와 필드 본문이
위치한다. 필드 본문은 필드 마커에 비해 들여쓰여져야 하며 여러 본문 요소를
포함살 수 있다. 필드 마커 뒤의 첫 번째 줄이 필드 본문의 들여쓰기를 결정한다::

    :날짜: 2001-08-16
    :버전: 1
    :저자: - Me
              - Myself
              - I
    :들여쓰기: 필드 마커기 꽤 길기 때문에, 필드 본문의 두 번째와 이후의 행들은
       첫 번째 행과 정렬될 필요는 없지만 필드 이름 마커에 비해서는 들여쓰기
       되어야 한다. 그리고 그 행들은 서로 정렬되어있어야 한다.
    :모수 i: 정수

여러 단어로 이루어진 필드 이름 안의 각 단어들의 해석은 응용 프로그램에 따라
다르다. 응용 프로그램은 필드 이름에 대한 구문을 정할 수 있다.
예를 들어 두 번째와 이후의 단어가 "인수"로 처리된다면 인용된 구절은
단일 인수로 다루어질 수 있고 "이름=값" 구문에 대한 직접적인 지원이
추가될 수 있다

Standard RFC822_ headers는 규정이 애매하기 때문에 이 구조를 위해 사용될
수 없다. 줄의 시작 부분에 있는 콜론 앞의 단어는 텍스트에서 공통적이다.
그러나 문서의 시작 부분에서 filed list가 일관적으로 쓰여지는 경우처럼
잘 정의된 컨텍스트에서는 standard RFC822 headers도 사용될 수 있다.

단순화시킨 구문 다이어그램 ::

    +--------------------+----------------------+
    | ":" 필드 이름 ":"   | 필드 본문            |
    +-------+------------+                      |
            | (본문 요소)+                      |
            +-----------------------------------+


Bibliographic Fields
````````````````````

Doctree elements: docinfo, author, authors, organization, contact,
version, status, date, copyright, field, topic.

field list가 문서 내에서 주석이 아닌 첫 번째 요소일 때(제목이 있으면
제목 다음에), 필드는 문서의 문헌(bibliographic) 자료로 변형될 수 있다.
이 문헌 자료는 책의 제목 페이지나 저작권 페이지 처럼 책의 전문(front matter)과
일치한다.

(아래에 있는) 지정된 특정한 필드 이름은 인식 된 다음 일치하는 doctree 요소로
변환되는데 대부분 "Docinfo" 요소의 하위 요소가 된다. 문서 구조에 맞춰서
재배열 될 수는 있지만 순서를 지정해줄 필요는 없다.
아래 쪽에서 달리 명시하지 않는 한, 문헌 요소의 각 필드 본문은 하나의 단락만
포함할 수 있다. 필드 본문은 `RCS keywords`_ 에 대해 확인되고 정리될 수 있다.
인식되지 않은 필드는 docinfo 요소 안의 일반 필드로 남겨진다.

지정된 bibliographic field 이름과 대응하는 doctree 요소는 다음과 같다:

- 필드 이름 "Author": author element.
- "Authors": authors.
- "Organization": organization.
- "Contact": contact.
- "Address": address.
- "Version": version.
- "Status": status.
- "Date": date.
- "Copyright": copyright.
- "Dedication": topic.
- "Abstract": topic.

"Authors" 필드는 ";"나 ","로 구분된 저자 리스트로 구성된 한 단락을 포함할수도
있고 각 요소가 저자 한 명당 한 단락으로 구성된 bullet list를 포함할 수도 있다.
";"가 먼저 확인되기 때문에 "Doe, Jane; Doe, John"로 쓸 수 있다.
스웨덴어 같은 특정한 언어의 경우 "Author"와 "Authors" 사이에 단복수의 구분이 없기
때문에 "Authors" 필드만이 제공된다. 그리고 한 사람의 이름은 "Author"로
해석된다. 만약 한 사람의 이름이 콤마를 포함한다면 구분을 해주기 위해서
이름의 끝에 세미콜론을 써야 한다: ":Authors: Doe, Jane;".

"Address" 필드는 여러줄로 된 우편 주소를 위한 것이다.
개행과 공백 문자가 보존된다.

"Dedication"과 "Abstract" 필드는 임의의 본문 요소를 포함할 수 있다.
그러나 각각의 본문 요소는 하나씩만 포함할 수 있다. 본문 요소는
docinfo 요소 바로 뒤에 "Dedication"이나 "Abstract" 제목을 가진 topic
요소가 된다.

이 field-name-to-element 맵핑은 다른 언어로 대체될 수 있다.
자세한 내용은 `DocInfo transform`_ 구현 문서를 참고하라.

지정되지 않았거나 일반적인(generic) 필드는 하나 이상의 단락이나 임의의
본문 요소를 포함한다. 필드 이름은 유요한 식별자 형식으로 변환된 후
"classes" 속성 값으로도 사용된다.


RCS Keywords
````````````

파서에 의해 인식된 `Bibliographic fields`_ 는 일반적으로 RCS [#]_ keywords에
대해 확인되고 정리된다 [#]_.  RCS keywords는 "$keyword$" 형식으로
소스 파일에 입력될 수 있고 일단 RCS나 CVS [#]_ 에 저장되면,
"$keyword: expansion text $"로 확장된다. 예를 들어, "Status" 필드는
"status" 요소로 변형될 것이다::

    :Status: $keyword: expansion text $

.. [#] Revision Control System.
.. [#] RCS keyword 처리를 중지시킬 수 있다 (구현되지 않음).
.. [#] Concurrent Versions System.  CVS는 RCS와 같은 키워드를 사용한다.

처리된 "status" 요소의 텍스트는 단순히 "expansion text"가 된다.
달러 표시 기호와 주요 RCS keyword 이름은 제거된다.

RCS keyword 처리는 필드 리스트가 bibliographic 컨텍스트에 있을 때만 시작된다.
(문서의 첫 번째 비 주석 구조, 제목이 있는 경우 제목 다음에 있는 첫 비 주석 구조).


Option Lists
------------

Doctree elements: option_list, option_list_item, option_group, option,
option_string, option_argument, description.

Option lists 커맨드라인 옵션, 설명, 프로그램 옵션 기록에 대한 리스트다.
예시::

    -a         전부 출력.
    -b         둘 다 출력 (이 설명 조금
               길다).
    -c arg     인수만 출력.
    --long     하루종일 출력.

    -p         이 옵션은 설명이 두 단락으로 이루어져있다.
               이 단락이 첫 번째다.

               이 단락이 두 번째다. 옵션 사이의 공백 행은 위처럼 생략되거나
               여기나 아래처럼 남아있을 수 있다.

    --very-long-option  VMS 스타일 옵션. 두 칸의 공백이 요구된다는
                        사실을 명심하라.

    --an-even-longer-option
               설명 부분은 다음줄부터 시작해도 된다.

    -2, --two  이 옵션은 두 변형(variants)이 있다.

    -f FILE, --file=FILE  이 두 옵션의 의미는 같다; 둘 다 인수를
                          받는다.

    /V         VMS/DOS 스타일 옵션.

reStructuredText에 의해 인식되는 옵션 종류는 여러가지가 존재한다:

- 짧은 POSIX 옵션은 대쉬 하나와 한 글자짜리 옵션으로 구성되어 있다.
- 긴 POSIX 옵션은 대쉬 두 개와 한 단어로 구성되어 있다; 몇몇 시스템은
  대쉬 하나를 사용한다.
- 구식 GNU 스타일 "플러스" 옵션은 플러스기호 하나와 한 글자 옵션으로
  구성되어 있다 ("플러스" 옵션은 사라졌으며, 사용이 권장되지 않는다).
- DOS/VMS 옵션 슬래쉬 하나와 옵션 한 글자 또는 한 단어로 구성되어 있다.

POSIX 스타일과 DOS/VMS 스타일 옵션은 도스나 윈도우즈 소프트웨어에서
모두 사용 가능하다. 위 스타일과 다른 변형은 종종 혼합되어 사용된다.
위의 이름은 단순히 편의를 위해서 선택되었다.

짧고 긴 POSIX 옵션을 위한 구문은 Python's getopt.py_ 모듈에 의해 지원되는
구문을 기반으로 한다. 이 모듈은 `GNU libc getopt_long()`_ 함수와 유사한 옵션
파서를 구연하지만 일부 제한이 있다. reStructuredText 옵션 리스트는 모든 변형
옵션 시스템을 지원하지는 않는다.

긴 POSIX와 DOS/VMS 옵션 단어는 커맨드라인에서 사용될 때 운영 시스템이나
응용 프로그램에 의해 잘릴 수 있지만, reStructuredText 옵션 리스트는
특수 구문으로 표시하거나 지원하지 않는다. 적용이 가능하다면
잘라내기(truncation)에 문서에 의해 지원되는 완전한 옵션 단어를 제공해야 한다

옵션 뒤에는 인수 placeholder가 올 수 있는데 설명 부분에서 역할과 구문에 대한
안내를 해주어야 한다. 옵션과 인수 placeholder 사이에 스페이스나 등호를
구분 기호로 사용할 수 있다. "-" 또는 "+"만 사용 가능한 짧은 옵션은 구분 기호
를 생략할 수 있다. 옵션 인수는 아래의 두 가지 형식중 하나를 차용해야 한다:

- 알파벳(``[a-zA-Z]``)으로 시작하고 문자, 숫자, 하이픈(``[a-zA-Z0-9_-]``)
  으로 구성되어야 한다.
- 화살괄호로 시작(``<``)해서  화살괄호로 끝나야(``>``) 한다; 괄호 내에서는
  화살괄호를 제외하고 어떤 문자를 써도 상관이 없다.

하나의 설명을 공유하는 여러 옵션 '동의어'가 나열될 될 수 있다.
그 경우 콤마와 스페이스로 구분돼야 한다.

옵션과 설명 부분은 최소한 두 칸의 스페이스로 떨어져 있어야 한다.
설명은 여러 본문 요소를 포함할 수 있다. 옵션 마커 다음 첫 줄이 설명 부분의
들여쓰기를 결정한다. 다른 종류의 리스트와 마찬가지로 option list의 첫 번쨰
항목의 앞과 마지막 항목의 뒤에 공백 행이 삽입되어야 하며 옵션 사이에서는
선택적으로 사용할 수 있다.

단순화된 구문 다이어그램::

    +----------------------------+-------------+
    | 옵션   [" " 인수]      "  " | 설명        |
    +-------+--------------------+             |
            | (본문 요소)+                      |
            +----------------------------------+


Literal Blocks
--------------

Doctree element: literal_block.

두 개의 콜론("::")으로 구성된 단락은 다음에 오는 텍스트 블락을 literal block
으로 변형시킨다. literal block은 들여쓰여지거나 인용 되어야 한다.
literal block 안에서는 마크업 처리가 되지 않는다. 일반적으로 고정폭 글꼴로
렌더링 된 채 있는 그대로 유지된다::

    이것은 일반적인 단락이다.  들여쓰여진 literal block이 다음에 위치한다.

    ::

        for a in [5,4,3,2,1]:   # 보이는 것처럼 이것은 프로그램 코드다
            print a
        print "it's..."
        # literal block은 들여쓰기가 끝나기 전까지 계속 이어진다

    이 텍스트는 첫 번째 단락의 들여쓰기 수준으로 돌아왔고, literal block의
    밖에 있기 때문에 일반적인 단락으로 처리된다.

콜론 두 개만으로 구성된 단락은 출력에서 완전히 제거된다. 빈 단락은
남지 않는다.

편의상 "::"는 단락의 끝에서 인식된다. 공백 문자 바로 앞에 쓰여지면 두 콜론은
출력에서 모두 제거된다 (이것은 "부분적으로 최소화된" 형식이다).
"::" 바로 앞에 텍스트가 오면, *하나의* 콜론만 출력에서 제거되고 하나의 콜론은
남아서 보이게 된다 (즉, "::"가 ":"로 대체된다; 이것은 "완전히 최소화된" 형식이다).

다시 말해서 아래의 형태는 모두 동일하다 (단락 다음에 오는 콜론에 주목하라):

1. 확장된 형태::

      단락:

      ::

          Literal block

2. 부분적으로 최소화된 형태::

      단락: ::

          Literal block

3. 완전히 최소화된 형태::

      단락::

          Literal block

literal block의 들여쓰기를 위해 필요한 최소한의 부분을 제외한 모든 공백
문자는 보존된다. literal block의 전후로 공백 행이 필요하지만 공백 행은
literal block의 일부로 포함되지는 않는다.


Indented Literal Blocks
```````````````````````

Indented literal blocks 주변 텍스트에 비해 들여쓰여져서 표기된다
(각 줄이 공백 문자로 시작해야 함). indented literal block의 각 라인에서
최소 들여쓰기 부분은 제거 된다. literal block은 연결되어 있을 필요는 없다;
들여쓰기된 텍스트의 섹션 사이에 공백 행을 삽입할 수 있다. literal block은
들여쓰기가 끝나는 부분에서 종료 된다.

구문 다이어그램::

    +------------------------------+
    | 단락                         |
    | ("::"로 끝남)                |
    +------------------------------+
       +---------------------------+
       | indented literal block    |
       +---------------------------+


Quoted Literal Blocks
`````````````````````

Quoted literal blocks는 들여쓰기되지 않은 이어진 텍스블락이며 각 행은
출력가능하면서 숫자나 문자가 아닌 똑같은 7-bit ASCII 문자 [#]_ 로 시작한다.
인용 문자는 처리된 문서에서 그대로 보존된다.

.. [#]
   아래는 사용 가능한 인용 문자들이다::

       ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~

   위 문자들은 sections_ 의 제목을 꾸밀 때 사용 가능한 문자들과 같다.

대화형 하스켈 프로그래밍이나 이메일 인용이 필요할 때 사용 가능하다::

    John Doe wrote::

    >> Great idea!
    >
    > Why didn't I think of that?

    You just did!  ;-)

구문 다이어그램::

    +------------------------------+
    | 단락                         |
    | ("::"로 끝남)                |
    +------------------------------+
    +------------------------------+
    | ">" 인용된 라인              |
    | ">" 공백 행 없이 이어져야 함  |
    +------------------------------+


Line Blocks
-----------

Doctree elements: line_block, line.  (New in Docutils 0.3.5.)

Line blocks 은 행의 구조가 중요한 주소 블럭(address blocks), 운문(verse)
(시, 노래 가사), 간소한 리스트 등을 나타낼 때 유용하다. Line blocks은
수직 막대("|")로 시작하는 행들의 그룹이다. 각각의 수직 막대는 새로운 행을
나타내기 떄문에 개행도 유지된다. 처음 들여쓰기도 내포된(nested)된 구조를
형성하기 때문에 중요하다. 인라인 마크업이 지원된다.
연속 행(Continuation lines)은 긴 행의 행갈이(wrapped)가 된 부분이다;
수직 막대 대신에 스페이스로 시작한다. 연속 행은 반드시 들여쓰여져야 하지만
위쪽의 텍스트와 왼쪽으로 똑같이 정렬되어 있을 필요는 없다. line block은
공백 행으로 끝난다.

아래는 연속 행을 설명하는 예시다::

    | Lend us a couple of bob till Thursday.
    | I'm absolutely skint.
    | But I'm expecting a postal order and I can pay you back
      as soon as it comes.
    | Love, Ewan.

새로운 행의 들여쓰기로 표시된 line blocks의 내포된 구조를 보여주는
예시다::

    Take it away, Eric the Orchestra Leader!

        | A one, two, a one two three four
        |
        | Half a bee, philosophically,
        |     must, *ipso facto*, half not be.
        | But half the bee has got to be,
        |     *vis a vis* its entity.  D'you see?
        |
        | But can a bee be said to be
        |     or not to be an entire bee,
        |         when half the bee is not a bee,
        |             due to some ancient injury?
        |
        | Singing...

구문 다이어그램::

    +------+-----------------------+
    | "| " | 행                    |
    +------| 연속 행               |
           +-----------------------+


Block Quotes
------------

Doctree element: block_quote, attribution.

literal block이나 다른 내용을 나타내는 마크업 없이 선행된 텍스트에 비해
들여쓰기 된 텍스트 블락은 block quote라고 한다. 본문요소와 인라인 마크업을 위한
모든 마크업은 block quote 안에서 계속 처리된다::

    이것은 block quote를 설명하는, 일반적인 단락이다.

        "It is my business to know things.  That is my trade."

        -- Sherlock Holmes

block quote은 attribution으로 끝날 수 있다: block quote에 맞춰 왼쪽 정렬된
"--", "---", 또는 엠 대쉬(em-dash)로 시작하는 텍스트 블럭을 attrubution이라고
한다. 만약 attribution이 여러 행으로 구성되어 있다면, 두 번째와 이후의 행들은
모두 반드시 왼쪽 가장자리가 정렬되어 있어야 한다.

attributions로 종료하면 여러 block quotes를 연속적으로 나타낼 수 있다.

    들여쓰여지지 않은 단락.

        Block quote 1.

        -- Attribution 1

        Block quote 2.

`Empty comments`_ 는 block quote를 흡수해버리는 선행 구조를
명시적으로 제거하기 위해 사용될 수 있다::

    * 리스트 항목.

    ..

        Block quote 3.

Empty comments는 block quotes를 분리시키는 데에도 사용할 수 있다::

        Block quote 4.

    ..

        Block quote 5.

block quote 전후로 공백 행이 필요하지만 이 공백 행들은 block quote
일부로 처리되지는 않는다.

Syntax diagram::

    +------------------------------+
    | (들여쓰기 현재                |
    | 레벨)                        |
    +------------------------------+
       +---------------------------+
       | block quote               |
       | (본문 요소)+               |
       |                           |
       | -- attribution 텍스트      |
       |    (선택적)               |
       +---------------------------+


Doctest Blocks
--------------

Doctree element: doctest_block.

Doctest blocks docstring으로 복사 붙여넣기 된 대화형 Python 세션이다.
예시를 통해 사용법을 설명하고 파이썬 표준 라이브러리에 있는 `doctest
module`_ 을 통해서 우아하고 강력한 테스트 환경을 제공한다

Doctest blocks는 파이썬 대화형 인터프리터의 메인 프롬프트인 ``">>> "`` 로
시작하는 텍스트 블럭이며, 공백 행으로 끝난다. Doctest blocks은 lteral block 구문을
요구하지 않으면서 literal block의 특수한 케이스로 처리된다. 둘 다 존재하면, the
literal block 구문이 Doctest block 구문보다 우선적으로 처리된다::

    이것은 일반적인 단락이다.

    >>> print 'this is a Doctest block'
    this is a Doctest block

    아래는 literal block이다::

        >>> 이것은 reStructuredText에 의해 doctest block으로 인식되지
        않는지만 doctest module에 의해 인식되기는 한다.

doctest blocks는 들여쓰기를 요구하지 않는다.


Tables
------

Doctree elements: table, tgroup, colspec, thead, tbody, row, entry.

ReStructuredText는 테이블 셀(cell)을 그리기 위한 두 가지 구문을 제공한다:
`Grid Tables`_ 과 `Simple Tables`_.

다른 본문 요소와 마찬가지로, 테이블의 전후에는 공백 행이 필요하다.
테이블의 왼쪽 가장자리는 선행하는 텍스트 블럭의 가장자리에 맞춰 정렬 되여야 한다;
들여쓰기 되어있을 경우 테이블은 blokc quote의 일부로 인식된다.

일단 분리가 되면, 각각의 테이블은 작은 문서로서 처리된다; 위쪽 및 아래쪽 셀
경계는 공백 행의 기능을 한다. 각 셀은 0개 이상의 본문 요소를 포함하고 있다.
셀의 컨텐츠는 처리되기 전에 제거되는 양쪽의 여백을 포함할 수 있다.


Grid Tables
```````````

Grid tables 격자 모양의 "ASCII art"를 통해서 완전한 테이블 표현을
제공한다. Grid tables는 임의의 셀 컨텐츠 (본문 요소)와 행, 열 병합을 모두
허용한다. 그러나 grid tables은 간단한 데이터 세트를 제작하기에는 복잡하고
번거로울 수 있다. `Emacs table mode`_ 는 grid tables를 쉽게 편집할 수 있게
도와주는 Emacs 도구다. 제한이 있지만 간단한 표현은 `Simple Tables`_ 를
참고하라.

Grid tables "-", "=", "|", "+"로 만들어진 그리드로 표현된다.
하이픈("-")은 수평적으로 행을 나누기 위해 쓰인다. 등호("=")는
테이블 본문의 헤더 행을 테이블 본문과 분리시키기 위해 사용될 수 있다
(`Emacs table mode`_ 에 의해 지원되지는 않는다). 수직 막대("|")는 열을
나누기 위해 사용된다. 플러스 기호("+")는 수직선과 수평선의 교차점을 표시하기
위해 사용된다. 예시::

    +------------------------+------------+----------+----------+
    | 헤더 행, 열1            | 헤더 2     | 헤더 3    | 헤더 4   |
    | (헤더 행은 선택적이다)   |            |          |          |
    +========================+============+==========+==========+
    | 본문 행 1, 열 1         | 열 2       | 열 3     | 열 4     |
    +------------------------+------------+----------+----------+
    | 본문 행 2               | 셀은 열끼리 병합될 수 있다.        |
    +------------------------+------------+---------------------+
    | 본문 행 3               | 셀은 행끼  | - 테이블 셀은        |
    +------------------------+ 리 병합될   | - 본문 요소를        |
    | 본문 행 4               | 수 있다.   | - 포함한다.          |
    +------------------------+------------+---------------------+

드물게 셑 텍스트와의 원하지 않는 상호작용을 피하기 위해서 주의해야 할
필요가 있다. 예를 들면 아래 테이블의 행 2는 열 2부터 열 4까지 병합되어 있다::

    +--------------+----------+-----------+-----------+
    | 행  1, 열  1 | 열 2      | 열 3      | 열 4      |
    +--------------+----------+-----------+-----------+
    | 행 2         |                                  |
    +--------------+----------+-----------+-----------+
    | 행 3         |          |           |           |
    +--------------+----------+-----------+-----------+

만약 수직 막대가 셀 안에서 사용되면, 실수로 열의 경계와 정렬되었을 때
의도하지 않게 영향을 줄 수도 있다::

    +--------------+----------+-----------+-----------+
    | 행 1, 열 1   | 열 2     | 열 3       | 열 4      |
    +--------------+----------+-----------+-----------+
    | 행 2         | Use the command ``ls | more``.   |
    +--------------+----------+-----------+-----------+
    | 행 3         |          |           |           |
    +--------------+----------+-----------+-----------+

여러 개의 해결책이 존재한다. 어어떤 해결책이 되었든 셀의 정사각형
경계의 연속성을 끊어버리면 된다. 한 가지 가능한 방법은 수직 막대 앞에
스페이스를 추가해 텍스트를 이동시켜버리는 것이다::

    +--------------+----------+-----------+-----------+
    | 행 1, 열 1   | 열 2     | 열 3       | 열 4      |
    +--------------+----------+-----------+-----------+
    | 행 2         |  Use the command ``ls | more``.  |
    +--------------+----------+-----------+-----------+
    | 행 3         |          |           |           |
    +--------------+----------+-----------+-----------+

다른 방법은 행 2에 한 줄을 추가하는 것이다::

    +--------------+----------+-----------+-----------+
    | 행 1, col 1  | 열 2     | 열 3       | 열 4      |
    +--------------+----------+-----------+-----------+
    | 행 2         | Use the command ``ls | more``.   |
    |              |                                  |
    +--------------+----------+-----------+-----------+
    | 행 3         |          |           |           |
    +--------------+----------+-----------+-----------+


Simple Tables
`````````````

Simple tables는 쉽고 간단하다. 하지만 단순한 데이터 셋의 제한적인 행 기반 테이블
표현만을 제공한다. 대부분의 셀에서 임의의 본문 요소가 표현될 수는 있지만
셀의 내용은 일반적으로 한 단락이다. Simple tables은 여러 행을 첫 번째 열을
제외한 나머지 열에서 여러 줄로 이루어진 행을 허용하고 열 병합은 가능하지만
행 병합은 가능하지 않다. 완전한 테이블 표현에 대해서는 위쪽의 `Grid Tables`_
를 참고하라.

Simple tables는 "="과 "-"로 만들어진 수평적인 경계로 표현된다.
등호("=")는 테이블의 위 아래 부분에 사용되고 테이블 본문과 테이블 헤더를
구분하기 위해 사용될 수도 있다. 하이픈("-")은 결합시킬 열에 밑줄을 표시해서
열의 병합을 나타내는 데 사용되고 명시적으로 행을 나누기 위해 선택적으로 사용
될 수도 있다.

simple table은 상단에 등호와 열 경계를 구분하기 위한 하나 이상의
스페이스로 시작된다 (두 개 이상의 스페이스를 추천한다). 너비와 상관없이
위쪽 경계는 *반드시* 테이블의 모든 열을 표시해야 한다. 테이블에는
섹션 헤더와 구별하기 위해 최소 두 개 이상의 열이 있을 것이다. 위쪽 경계
다음에는 헤더 행이 올 것이고, '='로 이루어진 밑줄이 선택적으로
그 다음에 올 수도 있는데 열의 경계를 스페이스로 다시 구분해야 한다.
테이블의 하단 경계로 해석될 수 있기 때문에 헤더 행 구분 기호 아레에
공백 행은 없어야 한다. 테이블의 하단 경계는 '=' 밑줄과 열을 구분하는
스페이스로 구성된다. 예를 들어 아래의 (진리 표)truth table는 열 3개와
하나의 헤더 행, 본문 행 4개로 이루어져 있다::

    =====  =====  =======
      A      B    A and B
    =====  =====  =======
    False  False  False
    True   False  False
    False  True   False
    True   True   True
    =====  =====  =======

'-' 밑줄은 인접한 열을 합치기 위해 열의 여백을 "채우는" 방식으로 열의 병합을
나타내는 데 사용할 수 있다. 열 병합 밑줄은 모든 열에 대하여 표시 되어야 하며
정해진 열의 경계에 맞춰서 정렬되어야 한다. 열 병합 밑줄을 포함하는 텍스트 줄은
다른 텍스트를 포함하면 안 된다. 열 병합 밑줄은 바로 위의 한 행에만 적용 된다.
아래는 헤더가 열 병합된 예시다::

    =====  =====  ======
       Inputs     Output
    ------------  ------
      A      B    A or B
    =====  =====  ======
    False  False  False
    True   False  True
    False  True   True
    True   True   True
    =====  =====  ======

각 텍스트 줄은 열 병합이 되었을 경우를 제외하고는 열의 경계를 스페이스로
표시해야 한다. 첫 번째 열의 셀이 비어있지 않은 한 각 텍스트 줄은 새로운
행으로 시작한다. 이 경우 텍스트의 줄은 연속 행으로 파싱 된다.
이러한 이유로 인해서 (연속 행이 *아닌*) 새 행의 첫 번째 열에 있는 셀은
*반드시* 텍스트를 포함해야 한다; 빈 셀은 해석에 문제를 일으킬 수 있다
(아래의 팁을 참고하라). 또한 이 메커니즘은 첫 번째 열의 셀을 한 줄의 텍스트로
제한한다. 이러한 제한을 피하려면 `grid tables`_ 을 사용하라.

.. Tip::

   처리된 출력물에서 첫 번째 컬럼의 텍스트 없이 새 행을 시작하고 싶다면
   아래의 방법 중 하나를 사용하라:

   * empty comment ("..")는 처리된 출력에서 생략된다
     (아래의 Comments_ 참고하라)

   * 스페이스가 뒤에 오는 backslash escape ("``\``") (위의 `Escaping
     Mechanism`_ 을 참고하라)

'-' 밑줄은 열 병합이 아닐 때도 사용할 수 있다. 이것은 특히 행이 여러 줄로
이루어진 긴 테이블에서 유용하다.

simple tables 내에서 공백 행은 사용 가능하다. 공백 행의 해석은
컨텍스트에 따라 다르다. 행 *사이에* 있는 공백 행은 무시된다.
여러 줄로 이루어진 행 *내부의* 공백 행은 셀 안에 있는 본문 요소나
단락을 나누어 준다.

가장 오른쪽 열은 경계가 없다; 텍스트는 테이블 경계로 표시되어진 테이블의
가장자리를 지나서 계속 이어질 수 있다. 그러나, 경계가 텍스트 전체를 포함할
수 있도록 충분히 길게 만드는 것을 추천한다.

아래의 예시는 연속행을 설명한다 (2행은 두 줄의 텍스트, 3행은 4줄의 텍스트로
이루어져 있다). 3행 2열의 공백 행은 단락을 나누고, 텍스트는 테이블의 오른쪽
경계를 지나서 연장되어 있고, 4 행의 첫 번째 열은 처리 후 출력될 떄 비어있게
다::

    =====  =====
    열  1  열  2
    =====  =====
    1      1행 2열.
    2      2행 2열.
           두번 째 단락.
    3      - 3행 2열.

           - 3행 2열의 bullet
             list.
    \      4행 ; 열은 비어있다.
    =====  =====


Explicit Markup Blocks
----------------------

explicit markup block은 텍스트 블럭이다:

- ".."와 공백 문자로 시작한다,
- 두 번째 줄부터는 첫 번째 줄보다 들여쓰기 되어야 한다,
- 들여쓰기 되지 않은 줄 앞에서 끝난다.

Explicit markup blocks은 ".."를 글머리 기호로 사용하는 bullet list
항목과 비슷하다. explicit markup 바로 다음에 오는 텍스트는 블럭 본문의
들여쓰기를 결정한다. 공통된 최대로 들여쓰기된 부분은 블럭 본문의 두 번째
줄부터 제거된다. 그러므로 첫 번째 구문이 한 라인에 있고 첫 번째 줄과
두 번째 줄의 들여쓰기가 달라야 한다면, 첫 번째 구문이 explicit markup과 같은
줄에서 시작하면 안된다.

explicit markup blocks과 다른 요소 사이에는 공백 행이 삽입되어야 하며
명백한 explicit markup block 사이에는 선택적으로 사용할 수 있다.

explicit markup 구문은, 각주, 인용, 하이퍼링크, 명령, 대체 정의, 코멘트를
위해 사용된다.


Footnotes
`````````

See also: `Footnote References`_.

Doctree elements: footnote_, label_.

Configuration settings:
`footnote_references <footnote_references setting_>`_.

.. _footnote: ../doctree.html#footnote
.. _label: ../doctree.html#label
.. _footnote_references setting:
   ../../user/config.html#footnote-references-html4css1-writer

각각의 각주는 explicit markup(".. ")으로 시작하고, 대괄호, 각주 라벨,
대활호, 공백문자, 들여쓰기된 본문 요소의 순으로 구성되어 있다.
각주 라벨로는 아래의 것들을 사용할 수 있다:

- 한 개 이상의 십진수,

- "#" 하나 (`auto-numbered footnotes`_ 참고),

- 간단한 참조 이름이 뒤에 오는 "#" (`autonumber label`_ 참고),
  또는

- "*" 하나 (`auto-symbol footnotes`_ 참고).

각주 내용 (본문 요소)는 최소한 스페이스 3개 이상으로 들여쓰여져야 한다.
각주에 있는 첫 번째 본문 요소는 각주 라벨과 같은 줄에서 시작할 수 있다.
그러나 첫 번째 요소가 같은 줄에 있고 남아있는 요소의 들여쓰기가 다르다면
첫 번째 요소는 반드시 각주 라벨 다음 줄부터 시작해야 한다. 그렇지 않으면
들여쓰기의 차이가 인식되지 않을 것이다.


각주는 문서의 끝 뿐만 아니라 어디에서나 삽입될 수 있다. 출력물에서 어디에
어떻게 나타날지는 처리 시스템에 따라 다르다.

아래는 직접 번호를 매긴 각주의 예시이다::

    .. [1] 본문 요소는 이곳에 위치한다.

각각의 각주는 자동적으로 자기 자신을 가리키는 하이퍼링크 타겟을 생성한다.
하이퍼링크 타겟 이름은 각주 라벨과 같다. `Auto-numbered footnotes`_ 는
각주 라벨과 참조 이름으로 번호를 생성한다. 메커니즘에 대한 자세한 설명은
`Implicit Hyperlink Targets`_ 를 참고하라.

구문 다이어그램::

    +-------+-------------------------+
    | ".. " | "[" 라벨 "]" 각주        |
    +-------+                         |
            | (본문 요소)+             |
            +-------------------------+


Auto-Numbered Footnotes
.......................

번호 기호("#")는 각주와 각주 참조의 자동적 넘버링을 요청하는 각주 라벨의
첫 번재 문자로 사용될 수 있다.

수동으로 넘버링을 한 각주가 존재하지 않을 경우 자동 넘버링을 요청하는 첫 번째
각주는 라벨 "1"을 할당 받고 두 번재는 라벨 "2", 나머지도 순서대로 라벨을 할당
받는다 (아래 `Mixed Manual and Auto-Numbered Footnotes`_ 참고).
자동으로 라벨 "1"을 받은 각주는 라벨이 외부적으로(explicitly) 지정되는
것 처럼 "1"인 내부(implicit) 하이퍼링크 타겟을 생성한다.


.. _autonumber label: `autonumber labels`_

각주는 자동 넘버링 ``[#label]`` 을 요청하는 동시에 외부적으로 라벨을
지정할 수 있다. 이 라벨은 _`autonumber labels` 이라고 불린다.
Autonumber labels는 두 가지 일을 한다:

- 각주 자신에 대해서 이름이 autonumber label인 ("#"를 포함하지 않음) 하이퍼 링크
  타겟을 생성한다.

- 또한 각주 참조나 하이퍼링크 참조로서, 자동 넘버링 된 각주가
  여러번 참조되는 것을 허용한다::

      만약 [#note]_ 가 첫 번째 각주 참조라면, "[1]"로 나타날 것이다.
      우리는 이것을 다시 [#note]_ 로 참조할 수 있고 "[1]"로 보일 것이다.
      또한 우리는 note_ 로 참조할 수 있다 (일반 내부 하이퍼링크 참조).

      .. [#note] 이 것은 "note"로 레이블된 각주이다.

넘버링은 참조의 순서가 아니라 각주의 순서에 따라 결졍된다. 자동 숫자 라벨
(``[#]_``) 각주 참조의 경우, 각주와 각주 참조가 같은 순서로 되어 있어야
하지만 정확히(in lock-step) 번갈아(alternate) 나올 필요는 없다::

    [#]_ 는 각주 1에 대한 참조 번호, [#]_ 는 각주 2에 대한 참조 번호다.

    .. [#] 이건 각주 1.
    .. [#] 각주 2.
    .. [#] 각주 3 이다.

    [#]_ 는 각주 3에 대한 참조 번호다.

각주가 자동 넘버링 된 각주 참조 번호이거나 여러 참조 번호가 굉장히 근접해 있을
경우 특별한 주의가 필요하다. 각주와 참조 번호는 문서에서 등장하는 순서에 따라
기록되며 사람이 읽어야 하는 순서와 같을 필요는 없다.


Auto-Symbol Footnotes
.....................

별표("*")는 각주와 각주 참조를 위한 자동 심벌(symbol) 생성을 요청하는 각주 라벨로
사용될 수 있다. 라벨에 다른 문자 없이 별표만 쓸 수도 있다::

    다음은 심벌 각주 참조: [*]_.

    .. [*] 이것이 각주다.

심벌은 대응하는 각주와 각주 참조에 라벨로 삽입될 것이다. 참조의 번호는
각주의 번호와 같다. 심벌 각주는 여러 참조를 가질 수 없다.

표준 Docutils 시스템은 각주 표시를 위해 아래의 심벌을 제공한다 [#]_:

- asterisk/star ("*")
- dagger (HTML character entity "&dagger;", Unicode U+02020)
- double dagger ("&Dagger;"/U+02021)
- section mark ("&sect;"/U+000A7)
- pilcrow or paragraph mark ("&para;"/U+000B6)
- number sign ("#")
- spade suit ("&spades;"/U+02660)
- heart suit ("&hearts;"/U+02665)
- diamond suit ("&diams;"/U+02666)
- club suit ("&clubs;"/U+02663)

.. [#] 이것은 The Chicago Manual of Style, 14th edition, section 12.51의
   "Note Reference Marks"에 있는 기호 리스트에서 영감을 받은 리스트다. This list was inspired by the list of symbols for  in , ,
   CMoS에서는 pilcorw 대신에 "Parallels" ("||")이 제공되었다.
   마지막 4개의 기호(카드 무늬)는 임의로 추가 되었다.

10 개 이상의 기호가 필요하다면 동일한 순서로, 예를 들어 기호를 두 배("**"), 세 배 해서
재사용할 수 있다.

.. Note:: auto-symbol footnotes를 사용할 때, 출력 인코딩 방식을 선택하는 것은
   중요하다. 많은 기호가 Latin-1 (ISO 8859-1) 같은 특정한 특정한 인코딩 방식에서
   제대로 지원되지 않는다. 출력 인코딩 방식을 위해 UTF-8을 사용하는 것을 추천한다.
   HTML과 XML 출력을 위한 대안으로는 "xmlcharrefreplace"을 사용하라.
   `output encoding error handler`__ 참조.

__ ../../user/config.html#output-encoding-error-handler


Mixed Manual and Auto-Numbered Footnotes
........................................

결과를 제대로 예측할 수는 없지만 수동 및 자동 각주 넘버링은 한 문서에서
동시에 사용될 수 있다. 수동 넘버링이 우선순위가 높다. 사용되지 않은
각주 번호만이 자동 넘버링 각주에 할당된다. 아래의 예시를 확인하라::

    [2]_ 는 수동으로 넘버링된 "2"가 되고,
    [#]_ 는 자동으로 넘버링 된 "3"이 되고,
    [#label]_ 는 라벨이 자동으로 넘버링 된 "1"이 된다.

    .. [2] 이 각주는 수동으로 넘버링 되었기 때문에 숫자가 고정된다.

    .. [#label] 이 자동으로 숫자 라벨링 된 각주는 "1"로 라벨링 된다.
       이것은 처음으로 자동 넘버링된 각주고 라벨 "1인" 다른 각주는 존재하지
       않는다. 각주 참조의 순서가 아니라 각주의 순서가 넘버링을 결정한다.

    .. [#] 이 각주는 "3"으로 라벨링 될 것이다. 이 각주는 두 번째로
       자동 넘버링 된 각주지만 라벨 "2"는 이미 사용되었다.


Citations
`````````

See also: `Citation References`_.

Doctree element: citation_

.. _citation: ../doctree.html#citation

인용은 ``[note]``나 ``[GVR2001]`` 같이 숫자가 아닌 라벨을 사용한다는 점을
제외하고는 각주와 동일하다. 인용 라벨은 단순한 `reference names`_ 이다
(공백 없이 대소문자를 구분하지 않은 문자, 숫자, 하이픈, 언더스코어, 구두점으로
이루어져있다. 인용은 각주와 달리 따로 렌더링 된다::

    이것은 인용 참조다: [CIT2002]_.

    .. [CIT2002] 이것은 인용이고 라벨이 문자인 것을 제외하면 각주와
       같다.


.. _hyperlinks:

Hyperlink Targets
`````````````````

Doctree element: target_.

.. _target: ../doctree.html#target

이것은 아래의 정의된 `implicit hyperlink targets`_ 와 구별하기 위해
_`explicit hyperlink targets` 라고도 불린다.

Hyperlink targets은 `hyperlink references`_ 에 의해 연결된 문서의
외부 혹은 내부의 위치와 동일하다.

Hyperlink targets은 이름이 있거나 익명으로 처리될 수 있다.
이름이 있는 hyperlink targets은 explicit markup start (".. ") 로 시작되고
언더스코어, 참조 이름, 콜론, 공백, 링크 블럭으로 이어진다::

    .. _하이퍼링크-이름: 링크-블럭

참조 이름은 대소문자를 구분하지 않고 띄어쓰기가 무효화된다. 자세한 사항과
예시는 `Reference Names`_ 를 참고하라.

익명 하이퍼링크 타겟은 explicit markup start (".. ")와 언더스코어 두 개,
콜론, 콩백, 링크 블럭으로 이루어져 있으며 참조 이름은 없다::

    .. __: 익명-하이퍼링크-타겟-링크-블럭

익명 하이퍼링크의 대체 구문은 언더스코어 두 개, 스페이스, 링크 블럭으로
이루어져있다::

    __ 익명-하이퍼링크-타겟-링크-블럭

아래의 `Anonymous Hyperlinks`_ 참고하라.

hyperlink targets은 세 종류가 있다: 내부, 외부, 우회.

1. _`Internal hyperlink targets` 는 빈 링크 블럭을 가지고 있다. 이 타겟은
   하이퍼링크를 한 지점에서 문서 내의 다른 지점으로 연결해주는 목적지를 제공한다.
   internal hyperlink target는 타겟을 따르는 요소를 가리킨다. [#]_ 예시::

       이 internal hyperlink를 클릭하면 아래에 있는 target_ 으로 데려다 준다.

       .. _target:

       위에 있는 하이퍼 링크 타겟은 이 단락을 가리킨다.

   Internal hyperlink targets "연결"될 수 잇다. 다수의 인접한
   internal hyperlink targets은 같은 요소를 가리킨다::

       .. _target1:
       .. _target2:

       타겟 "target1"과 "target2"는 같다; 두 타겟은 모두 이
       단락을 가리킨다.

   가리켜지는 요소가 링크 블럭이 URI로 되어 있는 (아래의 #2를 참고)
   external hyperlink target이라면 external hyperlink target의
   URI는 internal hyperlink targets로 전파된다; 전부 같은 URI를
   가리키게 된다. URI를 복제할 필요하 없다. 예를 들어, 아래의 3개의
   hyperlink targets은 같은 URI를 참조한다::

       .. _Python DOC-SIG 메일 리스트 아카이브:
       .. _archive:
       .. _Doc-SIG: http://mail.python.org/pipermail/doc-sig/

   인라인 형태의 internal hyperlink target도 사용할 수 있다;
   `Inline Internal Targets`_ 를 참고하라.

   .. [#] internal hyperlink target이 들여쓰기 된 텍스트 블럭의 끝에
      포함되어 있어도 사용할 수 있다. 이 작업을 통해서 타겟을 개별 리스트
      항목으로 설정할 수 있다 (리스트 전체에 적용되는 선행하는 내부 타겟으로서
      첫 번째로 사용 될 때를 제외하고)::

       * bullet list

         .. _`두 번째 항목`:

       * 하이퍼링크 타겟이 있는 두 번째 항목.


2. _`External hyperlink targets` 는 링크 블럭이 절대 또는 상대 URI나
   이메일 주소다. 예를 들어, 뒤에오는 입력을 받는다::

       See the Python_ home page for info.

       `Write to me`_ with your questions.

       .. _Python: http://www.python.org
       .. _Write to me: jdoe@example.com

   HTML로 처리된 이후, 하이퍼링크는 아래처럼 표시된다::

       See the <a href="http://www.python.org">Python</a> home page
       for info.

       <a href="mailto:jdoe@example.com">Write to me</a> with your
       questions.

   external hyperlink의 URI는 explicit markup start 와 타겟 이름이
   있는 같은 줄 또는 공백 행 없이 바로 다음에 들여쓰기 된 블럭으로 시작할
   수 있다. 링크 블럭이 여러 줄일 경우 블럭 내에서는 서로 이어진다.
   이스케이프 되지 않은 공백문자는 제거된다 (줄을 바꾸기 위한 공백만 허용이
   된다). 아래의 external hyperlink targets은 모두 동일하다::

       .. _one-liner: http://docutils.sourceforge.net/rst.html

       .. _starts-on-this-line: http://
          docutils.sourceforge.net/rst.html

       .. _entirely-below:
          http://docutils.
          sourceforge.net/rst.html

   이스케이프 된 공백 문자는, 의도적인 스페이스로 보존된다::

       .. _reference: ../local\ path\ with\ spaces.html

   external hyperlink target의 URI가 마지막 문자로 언더스코어를 취하면
   indirect hyperlink target으로 잘못 처리될 가능성이 있기 때문에 이스케이프
   되어야 한다::

       이 link_ 는 ``underscore_`` 라는 파일을 가리킨다.

       .. _link: underscore\_

   일반적으로 추천되지는 않지만 하이퍼링크 참조 안에서 URI를 직접 포함시키는
   것은 가능하다. 아래의 `Embedded URIs and Aliases`_ 를 참고하라.


3. _`Indirect hyperlink targets` 에 하이퍼링크 참조를 가지고 있다.
   아래의 예시에서 타겟 "one" 간접적으로 타겟 "two"가 참조하는 것을
   참조하고 타겟 "two"는 타겟 "three"가 참조하는 internal hyperlink target
   을 참조한다. 결과적으로 세 개의 참조는 모두 같은 것을 가리킨다::

       .. _one: two_
       .. _two: three_
       .. _three:

   문서의 다른 곳에 있는 `hyperlink references`_ 처럼, phrase-reference가
   링크 블럭에서 사용된다면 반드시 백 쿼트로 둘러싸여야 한다.
   `external hyperlink targets`_ 처럼, indirect hyperlink target의 링크
   블럭은 the explicit markup start가 있는 같은 줄이나 다음 줄에서 시작할
   수 있다. 링크 블록은 여러 줄로 분리될 수도 있으며 이 경우에는 정규화 되기 전에
   공백 문자로 연결된다.

   예를 들면, 아래의 indirect hyperlink targets은 모두 동일하다::

       .. _one-liner: `A HYPERLINK`_
       .. _entirely-below:
          `a    hyperlink`_
       .. _split: `A
          Hyperlink`_

   하이퍼링크 참조에 에일리어스(alias)를 직접 포함시키는 것도 가능하다.
   아래의 `Embedded URIs and Aliases`_ 를 참고하라.

그리고 참조 이름은 콜론을 포함하고 있다면:

- 구문은 반드시 백 쿼트로 싸여있거나::

      .. _`FAQTS: Computers: Programming: Languages: Python`:
         http://python.faqts.com/

- 링크 타켓에서 백 슬래쉬로 이스케이프 되어야 한다::

      .. _Chapter One\: "Tadpole Days":

      It's not easy being green...

중복 참조 이름의 해결을 위해서는 아래의 `Implicit Hyperlink Targets`_
참고하라.

구문 다이어그램::

    +-------+----------------------+
    | ".. " | "_" 이름 ":" 링크     |
    +-------+ 블럭                 |
            |                      |
            +----------------------+


Anonymous Hyperlinks
....................

`World Wide Web Consortium`_ 는 `HTML Techniques for Web Content
Accessibility Guidelines`_ 저자는 각 링크에 대한 타켓을 명확하게 식별할 것을
추천한다. 하이퍼링크 참조는 가능한 길어야 하지만 긴 하이퍼링크 이름을 타겟에
복제하는 것은 어렵고 에러를 일으키기 쉽다. Anonymous hyperlinks는 장황한
하이퍼링크 참조를 편리하게 하도록 설계되었고 그리고 `Auto-Numbered Footnotes`_
와 유사하다. 이것들은 특히 짧거나 하나로 구성된 문서에 유용하다. 그러나
이 장점은 쉽게 남용 되어서 텍스트를 읽을 수 없게 만들거나 문서를 보존할 수 없게
만든다. 사용할 때 주의할 필요가 있다.

익명 `hyperlink references`_ 는 하나가 아닌 두 언더스코어로 지정된다::

    `the web site of my favorite programming language`__.

익명 타겟은 ".. __:"로 시작하고; 참조 이름은 허용되지 않는다::

    .. __: http://www.python.org

더 쉽게 익명 타겟은 "__"만으로 시작할 수 있다::

    __ http://www.python.org

참조의 참조 이름은 참조와 참조 타겟의 이름과 매치되도록 사용되지 않는다.
대신에 문서에 있는 익명 하이퍼링크 참조의 순서와 타겟이 중요하다:
첫 번째 익명 참조는 첫 번째 익명 타겟과 연결된다. 문서의 익명 하이퍼링크 참조
갯수는 익명 타겟의 수와 같아야 된다. 가독성을 위해서 타겟이 참조와 가깝게 있도록
쓸 것을 추천한다. 익명 참조를 포함하는 텍스트를 편집할 때는 주의해야 한다:
참조를 재배열하거나 제거 추가하는 경우에 대응하는 타겟의 순서를 확인해야 한다.


Directives
``````````

Doctree elements: depend on the directive.

Directives는 reStructuredText를 위한 새로운 사전 구문을 추가할 필요 없이
새로운 구조에 대한 지원을 추가하는 방식의 확장 메커니즘이다 (directives는
지역적으로 추가적인 구문을 지원할 수 있다). 모든 (reference reStructuredText
parser에 등록되고 구현되어 있는) 기본 directives는 `reStructuredText
Directives`_ 문서에서 설명이 되어 있고, 언제든지 이용이 가능하다.
directives은 도메인에 따라 다르기 때문에, 문서를 처리할 때 사용하기 위해서는
특별한 조치가 필요할 수 있다.

예를 들어, 아래는 image_ 를 삽입할 수 있는 방식이다::

    .. image:: mylogo.jpeg

figure_ (캡션이 달린 그래프) 는 이런 식으로 삽입한다::

    .. figure:: larch.png

       The larch.

admonition_ (주석, 경고 등)은 다른 본문 요소를 포함한다::

    .. 주석:: 이것은 한 단락이다.

       - 여기에 bullet list가 위치한다.

Directives는 explicit markup start (".. ") followed
by the directive type, two colons, and whitespace (together called the
"directive marker").  Directive types are case-insensitive single
words (alphanumerics plus isolated internal hyphens, underscores,
plus signs, colons, and periods; no whitespace).  Two colons are used
after the directive type for these reasons:

- Two colons are distinctive, and unlikely to be used in common text.

- Two colons avoids clashes with common comment text like::

      .. Danger: modify at your own risk!

- If an implementation of reStructuredText does not recognize a
  directive (i.e., the directive-handler is not installed), a level-3
  (error) system message is generated, and the entire directive block
  (including the directive itself) will be included as a literal
  block.  Thus "::" is a natural choice.

The directive block is consists of any text on the first line of the
directive after the directive marker, and any subsequent indented
text.  The interpretation of the directive block is up to the
directive code.  There are three logical parts to the directive block:

1. Directive arguments.
2. Directive options.
3. Directive content.

Individual directives can employ any combination of these parts.
Directive arguments can be filesystem paths, URLs, title text, etc.
Directive options are indicated using `field lists`_; the field names
and contents are directive-specific.  Arguments and options must form
a contiguous block beginning on the first or second line of the
directive; a blank line indicates the beginning of the directive
content block.  If either arguments and/or options are employed by the
directive, a blank line must separate them from the directive content.
The "figure" directive employs all three parts::

    .. figure:: larch.png
       :scale: 50

       The larch.

Simple directives may not require any content.  If a directive that
does not employ a content block is followed by indented text anyway,
it is an error.  If a block quote should immediately follow a
directive, use an empty comment in-between (see Comments_ below).

Actions taken in response to directives and the interpretation of text
in the directive content block or subsequent text block(s) are
directive-dependent.  See `reStructuredText Directives`_ for details.

Directives are meant for the arbitrary processing of their contents,
which can be transformed into something possibly unrelated to the
original text.  It may also be possible for directives to be used as
pragmas, to modify the behavior of the parser, such as to experiment
with alternate syntax.  There is no parser support for this
functionality at present; if a reasonable need for pragma directives
is found, they may be supported.

Directives do not generate "directive" elements; they are a *parser
construct* only, and have no intrinsic meaning outside of
reStructuredText.  Instead, the parser will transform recognized
directives into (possibly specialized) document elements.  Unknown
directives will trigger level-3 (error) system messages.

Syntax diagram::

    +-------+-------------------------------+
    | ".. " | directive type "::" directive |
    +-------+ block                         |
            |                               |
            +-------------------------------+


Substitution Definitions
````````````````````````

Doctree element: substitution_definition.

Substitution definitions are indicated by an explicit markup start
(".. ") followed by a vertical bar, the substitution text, another
vertical bar, whitespace, and the definition block.  Substitution text
may not begin or end with whitespace.  A substitution definition block
contains an embedded inline-compatible directive (without the leading
".. "), such as "image_" or "replace_".  For example::

    The |biohazard| symbol must be used on containers used to
    dispose of medical waste.

    .. |biohazard| image:: biohazard.png

It is an error for a substitution definition block to directly or
indirectly contain a circular substitution reference.

`Substitution references`_ are replaced in-line by the processed
contents of the corresponding definition (linked by matching
substitution text).  Matches are case-sensitive but forgiving; if no
exact match is found, a case-insensitive comparison is attempted.

Substitution definitions allow the power and flexibility of
block-level directives_ to be shared by inline text.  They are a way
to include arbitrarily complex inline structures within text, while
keeping the details out of the flow of text.  They are the equivalent
of SGML/XML's named entities or programming language macros.

Without the substitution mechanism, every time someone wants an
application-specific new inline structure, they would have to petition
for a syntax change.  In combination with existing directive syntax,
any inline structure can be coded without new syntax (except possibly
a new directive).

Syntax diagram::

    +-------+-----------------------------------------------------+
    | ".. " | "|" substitution text "| " directive type "::" data |
    +-------+ directive block                                     |
            |                                                     |
            +-----------------------------------------------------+

Following are some use cases for the substitution mechanism.  Please
note that most of the embedded directives shown are examples only and
have not been implemented.

Objects
    Substitution references may be used to associate ambiguous text
    with a unique object identifier.

    For example, many sites may wish to implement an inline "user"
    directive::

        |Michael| and |Jon| are our widget-wranglers.

        .. |Michael| user:: mjones
        .. |Jon|     user:: jhl

    Depending on the needs of the site, this may be used to index the
    document for later searching, to hyperlink the inline text in
    various ways (mailto, homepage, mouseover Javascript with profile
    and contact information, etc.), or to customize presentation of
    the text (include username in the inline text, include an icon
    image with a link next to the text, make the text bold or a
    different color, etc.).

    The same approach can be used in documents which frequently refer
    to a particular type of objects with unique identifiers but
    ambiguous common names.  Movies, albums, books, photos, court
    cases, and laws are possible.  For example::

        |The Transparent Society| offers a fascinating alternate view
        on privacy issues.

        .. |The Transparent Society| book:: isbn=0738201448

    Classes or functions, in contexts where the module or class names
    are unclear and/or interpreted text cannot be used, are another
    possibility::

        4XSLT has the convenience method |runString|, so you don't
        have to mess with DOM objects if all you want is the
        transformed output.

        .. |runString| function:: module=xml.xslt class=Processor

Images
    Images are a common use for substitution references::

        West led the |H| 3, covered by dummy's |H| Q, East's |H| K,
        and trumped in hand with the |S| 2.

        .. |H| image:: /images/heart.png
           :height: 11
           :width: 11
        .. |S| image:: /images/spade.png
           :height: 11
           :width: 11

        * |Red light| means stop.
        * |Green light| means go.
        * |Yellow light| means go really fast.

        .. |Red light|    image:: red_light.png
        .. |Green light|  image:: green_light.png
        .. |Yellow light| image:: yellow_light.png

        |-><-| is the official symbol of POEE_.

        .. |-><-| image:: discord.png
        .. _POEE: http://www.poee.org/

    The "image_" directive has been implemented.

Styles [#]_
    Substitution references may be used to associate inline text with
    an externally defined presentation style::

        Even |the text in Texas| is big.

        .. |the text in Texas| style:: big

    The style name may be meaningful in the context of some particular
    output format (CSS class name for HTML output, LaTeX style name
    for LaTeX, etc), or may be ignored for other output formats (such
    as plaintext).

    .. @@@ This needs to be rethought & rewritten or removed:

       Interpreted text is unsuitable for this purpose because the set
       of style names cannot be predefined - it is the domain of the
       content author, not the author of the parser and output
       formatter - and there is no way to associate a style name
       argument with an interpreted text style role.  Also, it may be
       desirable to use the same mechanism for styling blocks::

           .. style:: motto
              At Bob's Underwear Shop, we'll do anything to get in
              your pants.

           .. style:: disclaimer
              All rights reversed.  Reprint what you like.

    .. [#] There may be sufficient need for a "style" mechanism to
       warrant simpler syntax such as an extension to the interpreted
       text role syntax.  The substitution mechanism is cumbersome for
       simple text styling.

Templates
    Inline markup may be used for later processing by a template
    engine.  For example, a Zope_ author might write::

        Welcome back, |name|!

        .. |name| tal:: replace user/getUserName

    After processing, this ZPT output would result::

        Welcome back,
        <span tal:replace="user/getUserName">name</span>!

    Zope would then transform this to something like "Welcome back,
    David!" during a session with an actual user.

Replacement text
    The substitution mechanism may be used for simple macro
    substitution.  This may be appropriate when the replacement text
    is repeated many times throughout one or more documents,
    especially if it may need to change later.  A short example is
    unavoidably contrived::

        |RST|_ is a little annoying to type over and over, especially
        when writing about |RST| itself, and spelling out the
        bicapitalized word |RST| every time isn't really necessary for
        |RST| source readability.

        .. |RST| replace:: reStructuredText
        .. _RST: http://docutils.sourceforge.net/rst.html

    Note the trailing underscore in the first use of a substitution
    reference.  This indicates a reference to the corresponding
    hyperlink target.

    Substitution is also appropriate when the replacement text cannot
    be represented using other inline constructs, or is obtrusively
    long::

        But still, that's nothing compared to a name like
        |j2ee-cas|__.

        .. |j2ee-cas| replace::
           the Java `TM`:super: 2 Platform, Enterprise Edition Client
           Access Services
        __ http://developer.java.sun.com/developer/earlyAccess/
           j2eecas/

    The "replace_" directive has been implemented.


Comments
````````

Doctree element: comment.

Arbitrary indented text may follow the explicit markup start and will
be processed as a comment element.  No further processing is done on
the comment block text; a comment contains a single "text blob".
Depending on the output formatter, comments may be removed from the
processed output.  The only restriction on comments is that they not
use the same syntax as any of the other explicit markup constructs:
substitution definitions, directives, footnotes, citations, or
hyperlink targets.  To ensure that none of the other explicit markup
constructs is recognized, leave the ".." on a line by itself::

    .. This is a comment
    ..
       _so: is this!
    ..
       [and] this!
    ..
       this:: too!
    ..
       |even| this:: !

.. _empty comments:

An explicit markup start followed by a blank line and nothing else
(apart from whitespace) is an "_`empty comment`".  It serves to
terminate a preceding construct, and does **not** consume any indented
text following.  To have a block quote follow a list or any indented
construct, insert an unindented empty comment in-between.

Syntax diagram::

    +-------+----------------------+
    | ".. " | comment              |
    +-------+ block                |
            |                      |
            +----------------------+


Implicit Hyperlink Targets
==========================

Implicit hyperlink targets are generated by section titles, footnotes,
and citations, and may also be generated by extension constructs.
Implicit hyperlink targets otherwise behave identically to explicit
`hyperlink targets`_.

Problems of ambiguity due to conflicting duplicate implicit and
explicit reference names are avoided by following this procedure:

1. `Explicit hyperlink targets`_ override any implicit targets having
   the same reference name.  The implicit hyperlink targets are
   removed, and level-1 (info) system messages are inserted.

2. Duplicate implicit hyperlink targets are removed, and level-1
   (info) system messages inserted.  For example, if two or more
   sections have the same title (such as "Introduction" subsections of
   a rigidly-structured document), there will be duplicate implicit
   hyperlink targets.

3. Duplicate explicit hyperlink targets are removed, and level-2
   (warning) system messages are inserted.  Exception: duplicate
   `external hyperlink targets`_ (identical hyperlink names and
   referenced URIs) do not conflict, and are not removed.

System messages are inserted where target links have been removed.
See "Error Handling" in `PEP 258`_.

The parser must return a set of *unique* hyperlink targets.  The
calling software (such as the Docutils_) can warn of unresolvable
links, giving reasons for the messages.


Inline Markup
=============

In reStructuredText, inline markup applies to words or phrases within
a text block.  The same whitespace and punctuation that serves to
delimit words in written text is used to delimit the inline markup
syntax constructs (see the `inline markup recognition rules`_ for
details).  The text within inline markup may not begin or end with
whitespace.  Arbitrary `character-level inline markup`_ is supported
although not encouraged.  Inline markup cannot be nested.

There are nine inline markup constructs.  Five of the constructs use
identical start-strings and end-strings to indicate the markup:

- emphasis_: "*"
- `strong emphasis`_: "**"
- `interpreted text`_: "`"
- `inline literals`_: "``"
- `substitution references`_: "|"

Three constructs use different start-strings and end-strings:

- `inline internal targets`_: "_`" and "`"
- `footnote references`_: "[" and "]_"
- `hyperlink references`_: "`" and "\`_" (phrases), or just a
  trailing "_" (single words)

`Standalone hyperlinks`_ are recognized implicitly, and use no extra
markup.

Inline markup recognition rules
-------------------------------

Inline markup start-strings and end-strings are only recognized if
the following conditions are met:

1. Inline markup start-strings must be immediately followed by
   non-whitespace.

2. Inline markup end-strings must be immediately preceded by
   non-whitespace.

3. The inline markup end-string must be separated by at least one
   character from the start-string.

4. Both, inline markup start-string and end-string must not be preceded by
   an unescaped backslash (except for the end-string of `inline literals`_).
   See `Escaping Mechanism`_ above for details.

5. If an inline markup start-string is immediately preceded by one of the
   ASCII characters ``' " < ( [ {`` or a similar
   non-ASCII character [#openers]_, it must not be followed by the
   corresponding closing character from ``' " ) ] } >`` or a similar non-ASCII
   character [#closers]_. (For quotes, matching characters can be any of
   the `quotation marks in international usage`_.)

If the configuration setting `simple-inline-markup`_ is False (default),
additional conditions apply to the characters "around" the
inline markup:

6. Inline markup start-strings must start a text block or be
   immediately preceded by

   * whitespace,
   * one of the ASCII characters ``- : / ' " < ( [ {``
   * or a similar non-ASCII punctuation character. [#pre-chars]_

7. Inline markup end-strings must end a text block or be immediately
   followed by

   * whitespace,
   * one of the ASCII characters ``- . , : ; ! ? \ / ' " ) ] } >``
   * or a similar non-ASCII punctuation character. [#post-chars]_

.. [#openers]    `Unicode categories`_ `Ps` (Open), `Pi` (Initial quote),
                 or `Pf` (Final quote). [#uni-version]_
.. [#closers]    Unicode categories `Pe` (Close), `Pi` (Initial quote),
                 or `Pf` (Final quote). [#uni-version]_
.. [#pre-chars]  Unicode categories `Ps` (Open), `Pi` (Initial quote),
                 `Pf` (Final quote), `Pd` (Dash), or `Po` (Other). [#uni-version]_
.. [#post-chars] Unicode categories  `Pe` (Close), `Pi` (Initial quote),
                 `Pf` (Final quote), `Pd` (Dash), or `Po` (Other). [#uni-version]_

.. [#uni-version] The category of some characters changed with the
   development of the Unicode standard.
   Docutils 0.13 uses `Unicode version 5.2.0`_.

.. _Unicode categories:
   http://www.unicode.org/Public/5.1.0/ucd/UCD.html#General_Category_Values
.. _Unicode version 5.2.0: http://www.unicode.org/Public/5.2.0/
.. _quotation marks in international usage:
   http://en.wikipedia.org/wiki/Quotation_mark,_non-English_usage

The inline markup recognition rules were devised to allow 90% of non-markup
uses of "*", "`", "_", and "|" without escaping. For example, none of the
following terms are recognized as containing inline markup strings:

- 2 * x  a ** b  (* BOM32_* ` `` _ __ | (breaks rule 1)
- || (breaks rule 3)
- "*" '|' (*) [*] {*} <*>
  ‘*’ ‚*‘ ‘*‚ ’*’ ‚*’
  “*” „*“ “*„ ”*” „*”
  »*« ›*‹ «*» »*» ›*› (breaks rule 5)
- 2*x a**b O(N**2) e**(x*y) f(x)*f(y) a|b file*.*
  __init__ __init__()  (breaks rule 6)

No escaping is required inside the following inline markup examples:

- ``*2 * x  *a **b *.txt*`` (breaks rule 2; renders as "*2 * x  *a **b *.txt*")
- ``*2*x a**b O(N**2) e**(x*y) f(x)*f(y) a*(1+2)*``
  (breaks rule 7; renders as "*2*x a**b O(N**2) e**(x*y) f(x)*f(y) a*(1+2)*")

It may be desirable to use `inline literals`_ for some of these anyhow,
especially if they represent code snippets.  It's a judgment call.

These cases *do* require either literal-quoting or escaping to avoid
misinterpretation::

    \*4, class\_, \*args, \**kwargs, \`TeX-quoted', \*ML, \*.txt

In most use cases, `inline literals`_ or `literal blocks`_ are the best
choice (by default, this also selects a monospaced font)::

    *4, class_, *args, **kwargs, `TeX-quoted', *ML, *.txt

For languages that don't use whitespace between words (e.g. Japanese or
Chinese) it is recommended to set `simple-inline-markup`_ to True and
eventually escape inline markup characters.
The examples breaking rules 6 and 7 above show which constructs may need
special attention.


.. _simple-inline-markup: ../../user/config.html#simple-inline-markup


Recognition order
-----------------

Inline markup delimiter characters are used for multiple constructs,
so to avoid ambiguity there must be a specific recognition order for
each character.  The inline markup recognition order is as follows:

- Asterisks: `Strong emphasis`_ ("**") is recognized before emphasis_
  ("*").

- Backquotes: `Inline literals`_ ("``"), `inline internal targets`_
  (leading "_`", trailing "`"), are mutually independent, and are
  recognized before phrase `hyperlink references`_ (leading "`",
  trailing "\`_") and `interpreted text`_ ("`").

- Trailing underscores: Footnote references ("[" + label + "]_") and
  simple `hyperlink references`_ (name + trailing "_") are mutually
  independent.

- Vertical bars: `Substitution references`_ ("|") are independently
  recognized.

- `Standalone hyperlinks`_ are the last to be recognized.


Character-Level Inline Markup
-----------------------------

It is possible to mark up individual characters within a word with
backslash escapes (see `Escaping Mechanism`_ above).  Backslash
escapes can be used to allow arbitrary text to immediately follow
inline markup::

    Python ``list``\s use square bracket syntax.

The backslash will disappear from the processed document.  The word
"list" will appear as inline literal text, and the letter "s" will
immediately follow it as normal text, with no space in-between.

Arbitrary text may immediately precede inline markup using
backslash-escaped whitespace::

    Possible in *re*\ ``Structured``\ *Text*, though not encouraged.

The backslashes and spaces separating "re", "Structured", and "Text"
above will disappear from the processed document.

.. CAUTION::

   The use of backslash-escapes for character-level inline markup is
   not encouraged.  Such use is ugly and detrimental to the
   unprocessed document's readability.  Please use this feature
   sparingly and only where absolutely necessary.


Emphasis
--------

Doctree element: emphasis.

Start-string = end-string = "*".

Text enclosed by single asterisk characters is emphasized::

    This is *emphasized text*.

Emphasized text is typically displayed in italics.


Strong Emphasis
---------------

Doctree element: strong.

Start-string = end-string = "**".

Text enclosed by double-asterisks is emphasized strongly::

    This is **strong text**.

Strongly emphasized text is typically displayed in boldface.


Interpreted Text
----------------

Doctree element: depends on the explicit or implicit role and
processing.

Start-string = end-string = "`".

Interpreted text is text that is meant to be related, indexed, linked,
summarized, or otherwise processed, but the text itself is typically
left alone.  Interpreted text is enclosed by single backquote
characters::

    This is `interpreted text`.

The "role" of the interpreted text determines how the text is
interpreted.  The role may be inferred implicitly (as above; the
"default role" is used) or indicated explicitly, using a role marker.
A role marker consists of a colon, the role name, and another colon.
A role name is a single word consisting of alphanumerics plus isolated
internal hyphens, underscores, plus signs, colons, and periods;
no whitespace or other characters are allowed.  A role marker is
either a prefix or a suffix to the interpreted text, whichever reads
better; it's up to the author::

    :role:`interpreted text`

    `interpreted text`:role:

Interpreted text allows extensions to the available inline descriptive
markup constructs.  To emphasis_, `strong emphasis`_, `inline
literals`_, and `hyperlink references`_, we can add "title reference",
"index entry", "acronym", "class", "red", "blinking" or anything else
we want.  Only pre-determined roles are recognized; unknown roles will
generate errors.  A core set of standard roles is implemented in the
reference parser; see `reStructuredText Interpreted Text Roles`_ for
individual descriptions.  The role_ directive can be used to define
custom interpreted text roles.  In addition, applications may support
specialized roles.


Inline Literals
---------------

Doctree element: literal.

Start-string = end-string = "``".

Text enclosed by double-backquotes is treated as inline literals::

    This text is an example of ``inline literals``.

Inline literals may contain any characters except two adjacent
backquotes in an end-string context (according to the recognition
rules above).  No markup interpretation (including backslash-escape
interpretation) is done within inline literals.

Line breaks are *not* preserved in inline literals.  Although a
reStructuredText parser will preserve runs of spaces in its output,
the final representation of the processed document is dependent on the
output formatter, thus the preservation of whitespace cannot be
guaranteed.  If the preservation of line breaks and/or other
whitespace is important, `literal blocks`_ should be used.

Inline literals are useful for short code snippets.  For example::

    The regular expression ``[+-]?(\d+(\.\d*)?|\.\d+)`` matches
    floating-point numbers (without exponents).


Hyperlink References
--------------------

Doctree element: reference.

- Named hyperlink references:

  - No start-string, end-string = "_".
  - Start-string = "`", end-string = "\`_".  (Phrase references.)

- Anonymous hyperlink references:

  - No start-string, end-string = "__".
  - Start-string = "`", end-string = "\`__".  (Phrase references.)

Hyperlink references are indicated by a trailing underscore, "_",
except for `standalone hyperlinks`_ which are recognized
independently.  The underscore can be thought of as a right-pointing
arrow.  The trailing underscores point away from hyperlink references,
and the leading underscores point toward `hyperlink targets`_.

Hyperlinks consist of two parts.  In the text body, there is a source
link, a reference name with a trailing underscore (or two underscores
for `anonymous hyperlinks`_)::

    See the Python_ home page for info.

A target link with a matching reference name must exist somewhere else
in the document.  See `Hyperlink Targets`_ for a full description).

`Anonymous hyperlinks`_ (which see) do not use reference names to
match references to targets, but otherwise behave similarly to named
hyperlinks.


Embedded URIs and Aliases
`````````````````````````

A hyperlink reference may directly embed a target URI or (since
Docutils 0.11) a hyperlink reference within angle brackets ("<...>")
as follows::

    See the `Python home page <http://www.python.org>`_ for info.

    This `link <Python home page_>`_ is an alias to the link above.

This is exactly equivalent to::

    See the `Python home page`_ for info.

    This link_ is an alias to the link above.

    .. _Python home page: http://www.python.org
    .. _link: `Python home page`_

The bracketed URI must be preceded by whitespace and be the last text
before the end string.

With a single trailing underscore, the reference is named and the same
target URI may be referred to again.
With two trailing underscores, the reference and target are both
anonymous, and the target cannot be referred to again.  These are
"one-off" hyperlinks.  For example::

    `RFC 2396 <http://www.rfc-editor.org/rfc/rfc2396.txt>`__ and `RFC
    2732 <http://www.rfc-editor.org/rfc/rfc2732.txt>`__ together
    define the syntax of URIs.

Equivalent to::

    `RFC 2396`__ and `RFC 2732`__ together define the syntax of URIs.

    __ http://www.rfc-editor.org/rfc/rfc2396.txt
    __ http://www.rfc-editor.org/rfc/rfc2732.txt

`Standalone hyperlinks`_ are treated as URIs, even if they end with an
underscore like in the example of a Python function documentation::

    `__init__ <http:example.py.html#__init__>`__

If a target URI that is not recognized as `standalone hyperlink`_ happens
to end with an underscore, this needs to be backslash-escaped to avoid
being parsed as hyperlink reference. For example ::

    Use the `source <parrots.txt\_>`__.

creates an anonymous reference to the file ``parrots.txt_``.

If the reference text happens to end with angle-bracketed text that is
*not* a URI or hyperlink reference, at least one angle-bracket needs to
be backslash-escaped or an escaped space should follow. For example, here
are three references to titles describing a tag::

    See `HTML Element: \<a>`_, `HTML Element: <b\> `_, and
    `HTML Element: <c>\ `_.

The reference text may also be omitted, in which case the URI will be
duplicated for use as the reference text.  This is useful for relative
URIs where the address or file name is also the desired reference
text::

    See `<a_named_relative_link>`_ or `<an_anonymous_relative_link>`__
    for details.

.. CAUTION::

   This construct offers easy authoring and maintenance of hyperlinks
   at the expense of general readability.  Inline URIs, especially
   long ones, inevitably interrupt the natural flow of text.  For
   documents meant to be read in source form, the use of independent
   block-level `hyperlink targets`_ is **strongly recommended**.  The
   embedded URI construct is most suited to documents intended *only*
   to be read in processed form.


Inline Internal Targets
------------------------

Doctree element: target.

Start-string = "_`", end-string = "`".

Inline internal targets are the equivalent of explicit `internal
hyperlink targets`_, but may appear within running text.  The syntax
begins with an underscore and a backquote, is followed by a hyperlink
name or phrase, and ends with a backquote.  Inline internal targets
may not be anonymous.

For example, the following paragraph contains a hyperlink target named
"Norwegian Blue"::

    Oh yes, the _`Norwegian Blue`.  What's, um, what's wrong with it?

See `Implicit Hyperlink Targets`_ for the resolution of duplicate
reference names.


Footnote References
-------------------

See also: Footnotes_

Doctree element: footnote_reference_.

Configuration settings:
`footnote_references <footnote_references setting_>`_,
trim_footnote_reference_space_.

.. _footnote_reference: ../doctree.html#footnote-reference
.. _trim_footnote_reference_space:
   ../../user/config.html#trim-footnote-reference-space

Start-string = "[", end-string = "]_".

Each footnote reference consists of a square-bracketed label followed
by a trailing underscore.  Footnote labels are one of:

- one or more digits (i.e., a number),

- a single "#" (denoting `auto-numbered footnotes`_),

- a "#" followed by a simple reference name (an `autonumber label`_),
  or

- a single "*" (denoting `auto-symbol footnotes`_).

For example::

    Please RTFM [1]_.

    .. [1] Read The Fine Manual

`Inline markup recognition rules`_ may require whitespace in front of the
footnote reference. To remove the whitespace from the output, use an
escaped whitespace character (see `Escaping Mechanism`_) or set the
trim_footnote_reference_space_ configuration setting. Leading whitespace
is removed by default, if the `footnote_references setting`_ is
"superscript".


Citation References
-------------------

See also: Citations_

Doctree element: citation_reference_.

.. _citation_reference: ../doctree.html#citation_reference

Start-string = "[", end-string = "]_".

Each citation reference consists of a square-bracketed label followed
by a trailing underscore.  Citation labels are simple `reference
names`_ (case-insensitive single words, consisting of alphanumerics
plus internal hyphens, underscores, and periods; no whitespace).

For example::

    Here is a citation reference: [CIT2002]_.


Substitution References
-----------------------

Doctree element: substitution_reference, reference.

Start-string = "|", end-string = "|" (optionally followed by "_" or
"__").

Vertical bars are used to bracket the substitution reference text.  A
substitution reference may also be a hyperlink reference by appending
a "_" (named) or "__" (anonymous) suffix; the substitution text is
used for the reference text in the named case.

The processing system replaces substitution references with the
processed contents of the corresponding `substitution definitions`_
(which see for the definition of "correspond").  Substitution
definitions produce inline-compatible elements.

Examples::

    This is a simple |substitution reference|.  It will be replaced by
    the processing system.

    This is a combination |substitution and hyperlink reference|_.  In
    addition to being replaced, the replacement text or element will
    refer to the "substitution and hyperlink reference" target.

.. _standalone hyperlink:

Standalone Hyperlinks
---------------------

Doctree element: reference.

No start-string or end-string.

A URI (absolute URI [#URI]_ or standalone email address) within a text
block is treated as a general external hyperlink with the URI itself
as the link's text.  For example::

    See http://www.python.org for info.

would be marked up in HTML as::

    See <a href="http://www.python.org">http://www.python.org</a> for
    info.

Two forms of URI are recognized:

1. Absolute URIs.  These consist of a scheme, a colon (":"), and a
   scheme-specific part whose interpretation depends on the scheme.

   The scheme is the name of the protocol, such as "http", "ftp",
   "mailto", or "telnet".  The scheme consists of an initial letter,
   followed by letters, numbers, and/or "+", "-", ".".  Recognition is
   limited to known schemes, per the `Official IANA Registry of URI
   Schemes`_ and the W3C's `Retired Index of WWW Addressing Schemes`_.

   The scheme-specific part of the resource identifier may be either
   hierarchical or opaque:

   - Hierarchical identifiers begin with one or two slashes and may
     use slashes to separate hierarchical components of the path.
     Examples are web pages and FTP sites::

         http://www.python.org

         ftp://ftp.python.org/pub/python

   - Opaque identifiers do not begin with slashes.  Examples are
     email addresses and newsgroups::

         mailto:someone@somewhere.com

         news:comp.lang.python

   With queries, fragments, and %-escape sequences, URIs can become
   quite complicated.  A reStructuredText parser must be able to
   recognize any absolute URI, as defined in RFC2396_ and RFC2732_.

2. Standalone email addresses, which are treated as if they were
   absolute URIs with a "mailto:" scheme.  Example::

       someone@somewhere.com

Punctuation at the end of a URI is not considered part of the URI,
unless the URI is terminated by a closing angle bracket (">").
Backslashes may be used in URIs to escape markup characters,
specifically asterisks ("*") and underscores ("_") which are vaid URI
characters (see `Escaping Mechanism`_ above).

.. [#URI] Uniform Resource Identifier.  URIs are a general form of
   URLs (Uniform Resource Locators).  For the syntax of URIs see
   RFC2396_ and RFC2732_.


Units
=====

(New in Docutils 0.3.10.)

All measures consist of a positive floating point number in standard
(non-scientific) notation and a unit, possibly separated by one or
more spaces.

Units are only supported where explicitly mentioned in the reference
manuals.


Length Units
------------

The following length units are supported by the reStructuredText
parser:

* em (ems, the height of the element's font)
* ex (x-height, the height of the letter "x")
* px (pixels, relative to the canvas resolution)
* in (inches; 1in=2.54cm)
* cm (centimeters; 1cm=10mm)
* mm (millimeters)
* pt (points; 1pt=1/72in)
* pc (picas; 1pc=12pt)

This set corresponds to the `length units in CSS`_.

(List and explanations taken from
http://www.htmlhelp.com/reference/css/units.html#length.)

The following are all valid length values: "1.5em", "20 mm", ".5in".

Length values without unit are completed with a writer-dependent
default (e.g. px with `html4css1`, pt with `latex2e`). See the writer
specific documentation in the `user doc`__ for details.

.. _length units in CSS:
   http://www.w3.org/TR/CSS2/syndata.html#length-units

__ ../../user/

Percentage Units
----------------

Percentage values have a percent sign ("%") as unit.  Percentage
values are relative to other values, depending on the context in which
they occur.


----------------
 Error Handling
----------------

Doctree element: system_message, problematic.

Markup errors are handled according to the specification in `PEP
258`_.


.. _reStructuredText: http://docutils.sourceforge.net/rst.html
.. _Docutils: http://docutils.sourceforge.net/
.. _The Docutils Document Tree: ../doctree.html
.. _Docutils Generic DTD: ../docutils.dtd
.. _transforms:
   http://docutils.sourceforge.net/docutils/transforms/
.. _Grouch: http://www.mems-exchange.org/software/grouch/
.. _RFC822: http://www.rfc-editor.org/rfc/rfc822.txt
.. _DocTitle transform:
.. _DocInfo transform:
   http://docutils.sourceforge.net/docutils/transforms/frontmatter.py
.. _getopt.py:
   http://www.python.org/doc/current/lib/module-getopt.html
.. _GNU libc getopt_long():
   http://www.gnu.org/software/libc/manual/html_node/Getopt-Long-Options.html
.. _doctest module:
   http://www.python.org/doc/current/lib/module-doctest.html
.. _Emacs table mode: http://table.sourceforge.net/
.. _Official IANA Registry of URI Schemes:
   http://www.iana.org/assignments/uri-schemes
.. _Retired Index of WWW Addressing Schemes:
   http://www.w3.org/Addressing/schemes.html
.. _World Wide Web Consortium: http://www.w3.org/
.. _HTML Techniques for Web Content Accessibility Guidelines:
   http://www.w3.org/TR/WCAG10-HTML-TECHS/#link-text
.. _image: directives.html#image
.. _replace: directives.html#replace
.. _meta: directives.html#meta
.. _figure: directives.html#figure
.. _admonition: directives.html#admonitions
.. _role: directives.html#custom-interpreted-text-roles
.. _reStructuredText Directives: directives.html
.. _reStructuredText Interpreted Text Roles: roles.html
.. _RFC2396: http://www.rfc-editor.org/rfc/rfc2396.txt
.. _RFC2732: http://www.rfc-editor.org/rfc/rfc2732.txt
.. _Zope: http://www.zope.com/
.. _PEP 258: ../../peps/pep-0258.html


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   End:
